{
  "hash": "5855e67c591298fbe4cc93d9283f3d42",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"4A: Spatial Weights and Applications\"\nsubtitle: \"In this exercise, we will learn to compute spatial weights, visualize spatial distributions, and create spatially lagged variables using various functions from R packages such as sf,spdep, and tmap.\"\n# draft: true\ndate: \"Sep 08, 2024\"\ndate-modified: \"last-modified\"\nauthor: Teng Kok Wai (Walter)\nexecute:\n  echo: true\n  eval: true\n  freeze: true\n  message: false\n  warning: false\nformat:\n  html:\n    toc: true\nnumber-sections: true\nnumber-offset: 1\neditor: visual\n---\n\n\n\n## Exercise 4A Reference\n\n[R for Geospatial Data Science and Analytics - 8  Spatial Weights and Applications](https://r4gdsa.netlify.app/chap08.html)\n\n## Overview\n\nIn this exercise, we will learn to compute spatial weights, visualize spatial distributions, and create spatially lagged variables using various functions from R packages such as **sf**, **spdep**, and **tmap**.\n\n## Learning Outcome\n\n- Import geospatial data using functions from the **sf** package.\n- Import CSV data using functions from the **readr** package.\n- Perform relational joins using functions from the **dplyr** package.\n- Compute spatial weights with functions from the **spdep** package.\n- Calculate spatially lagged variables using functions from the **spdep** package.\n\n## The Data\n\nThe following 2 datasets will be used in this exercise.\n\n| **Data Set**              | **Description**                                                  | **Format**           |\n|---------------------------|------------------------------------------------------------------|----------------------|\n| Hunan county boundary layer | Geospatial data set representing the county boundaries of Hunan | ESRI Shapefile       |\n| Hunan_2012.csv            | Contains selected local development indicators for Hunan in 2012 | CSV                  |\n\n## Installing and Loading the R Packages\n\nThe following R packages will be used in this exercise:\n\n\n| **Package**  | **Purpose**                                                                       | **Use Case in Exercise**                                                                                     |\n|--------------|-----------------------------------------------------------------------------------|----------------------------------------------------------------------------------------------------------------|\n| **sf**       | Imports, manages, and processes vector-based geospatial data.                     | Handling vector geospatial data such as the Hunan county boundary layer in shapefile format.                   |\n| **spdep**    | Provides functions for spatial dependence analysis, including spatial weights and spatial autocorrelation. | Computing spatial weights and creating spatially lagged variables.                                             |\n| **tmap**     | Creates static and interactive thematic maps using cartographic quality elements.  | Visualizing regional development indicators and plotting maps showing spatial relationships and patterns.      |\n| **tidyverse**| A collection of packages for data science tasks such as data manipulation, visualization, and modeling.   | Importing CSV files, wrangling data, and performing relational joins.                                          |\n| **knitr**    | Enables dynamic report generation and integration of R code with documents.        | Formatting output, creating tables, and generating reports for the exercise.                                   |\n\n\nTo install and load these packages, use the following code:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\npacman::p_load(sf, spdep, tmap, tidyverse, knitr)\n```\n:::\n\n\n\n## Import Data and Preparation\n\nIn this section, we will perform 3 necessary steps to prepare the data for analysis.\n\n### Import Geospatial Shapefile\n\nFirstly, we will use [`st_read()`](https://r-spatial.github.io/sf/reference/st_read.html) of **sf** package to import Hunan shapefile into R. The imported shapefile will be **simple features** Object of **sf**.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhunan <- st_read(dsn = \"data/geospatial\", \n                 layer = \"Hunan\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nReading layer `Hunan' from data source \n  `/Users/walter/code/isss626/isss626-gaa/Hands-on_Ex/Hands-on_Ex04/data/geospatial' \n  using driver `ESRI Shapefile'\nSimple feature collection with 88 features and 7 fields\nGeometry type: POLYGON\nDimension:     XY\nBounding box:  xmin: 108.7831 ymin: 24.6342 xmax: 114.2544 ymax: 30.12812\nGeodetic CRS:  WGS 84\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ndim(hunan)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 88  8\n```\n\n\n:::\n:::\n\n\n\n### Import Aspatial csv File\n\nNext, we will import *Hunan_2012.csv* into R by using `read_csv()` of **readr** package. The output is R dataframe class.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhunan2012 <- read_csv(\"data/aspatial/Hunan_2012.csv\")\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ndim(hunan2012)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 88 29\n```\n\n\n:::\n:::\n\n\n\n### Perform Relational Join\n\nBefore we perform relational join, let's observe the columns in each dataset and only select the columns that we need.\n\n1. `hunan` columns:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nprint(colnames(hunan))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"NAME_2\"     \"ID_3\"       \"NAME_3\"     \"ENGTYPE_3\"  \"Shape_Leng\"\n[6] \"Shape_Area\" \"County\"     \"geometry\"  \n```\n\n\n:::\n:::\n\n\n\n2. `hunan2012` columns:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nprint(colnames(hunan2012))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1] \"County\"      \"City\"        \"avg_wage\"    \"deposite\"    \"FAI\"        \n [6] \"Gov_Rev\"     \"Gov_Exp\"     \"GDP\"         \"GDPPC\"       \"GIO\"        \n[11] \"Loan\"        \"NIPCR\"       \"Bed\"         \"Emp\"         \"EmpR\"       \n[16] \"EmpRT\"       \"Pri_Stu\"     \"Sec_Stu\"     \"Household\"   \"Household_R\"\n[21] \"NOIP\"        \"Pop_R\"       \"RSCG\"        \"Pop_T\"       \"Agri\"       \n[26] \"Service\"     \"Disp_Inc\"    \"RORP\"        \"ROREmp\"     \n```\n\n\n:::\n:::\n\n\n\nAfter merging:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhunan_joined <- left_join(hunan,hunan2012)\nprint(colnames(hunan_joined))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1] \"NAME_2\"      \"ID_3\"        \"NAME_3\"      \"ENGTYPE_3\"   \"Shape_Leng\" \n [6] \"Shape_Area\"  \"County\"      \"City\"        \"avg_wage\"    \"deposite\"   \n[11] \"FAI\"         \"Gov_Rev\"     \"Gov_Exp\"     \"GDP\"         \"GDPPC\"      \n[16] \"GIO\"         \"Loan\"        \"NIPCR\"       \"Bed\"         \"Emp\"        \n[21] \"EmpR\"        \"EmpRT\"       \"Pri_Stu\"     \"Sec_Stu\"     \"Household\"  \n[26] \"Household_R\" \"NOIP\"        \"Pop_R\"       \"RSCG\"        \"Pop_T\"      \n[31] \"Agri\"        \"Service\"     \"Disp_Inc\"    \"RORP\"        \"ROREmp\"     \n[36] \"geometry\"   \n```\n\n\n:::\n:::\n\n\n\nThen only select the columns that we need:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhunan <- hunan_joined %>%\n  select(1:4, 7, 15)\n\nprint(colnames(hunan))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"NAME_2\"    \"ID_3\"      \"NAME_3\"    \"ENGTYPE_3\" \"County\"    \"GDPPC\"    \n[7] \"geometry\" \n```\n\n\n:::\n:::\n\n\n\n\nIn the code above, we use the `left_join()` function to merge the `hunan` `SpatialPolygonsDataFrame` with the `hunan2012` dataframe. The join is based on the column named `County`, which is common to both datasets. This allows us to match rows by their corresponding counties.\n\nAfter the join, the `select()` function is used to retain a subset of columns from the merged dataset. We can briefly observe the joined output below.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhead(hunan)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nSimple feature collection with 6 features and 6 fields\nGeometry type: POLYGON\nDimension:     XY\nBounding box:  xmin: 110.4922 ymin: 28.61762 xmax: 112.3013 ymax: 30.12812\nGeodetic CRS:  WGS 84\n   NAME_2  ID_3  NAME_3   ENGTYPE_3  County GDPPC\n1 Changde 21098 Anxiang      County Anxiang 23667\n2 Changde 21100 Hanshou      County Hanshou 20981\n3 Changde 21101  Jinshi County City  Jinshi 34592\n4 Changde 21102      Li      County      Li 24473\n5 Changde 21103   Linli      County   Linli 25554\n6 Changde 21104  Shimen      County  Shimen 27137\n                        geometry\n1 POLYGON ((112.0625 29.75523...\n2 POLYGON ((112.2288 29.11684...\n3 POLYGON ((111.8927 29.6013,...\n4 POLYGON ((111.3731 29.94649...\n5 POLYGON ((111.6324 29.76288...\n6 POLYGON ((110.8825 30.11675...\n```\n\n\n:::\n:::\n\n\n\n## Visualising Regional Development Indicator\n\nTo visualize the regional development indicator, we can prepare a base map and a choropleth map to show the distribution of GDPPC 2012 (GDP per capita) by using `qtm()` of **tmap** package.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbasemap <- tm_shape(hunan) +\n  tm_polygons() +\n  tm_text(\"NAME_3\", size=0.5)\n\ngdppc <- qtm(hunan, \"GDPPC\")\ntmap_arrange(basemap, gdppc, asp=1, ncol=2)\n```\n\n::: {.cell-output-display}\n![](Hands-on_Ex04a_files/figure-html/unnamed-chunk-11-1.png){width=672}\n:::\n:::\n\n\n\n::: callout-note\n**Intepretation**\nThe choropleth map on the right visualizes the distribution of GDP per capita (GDPPC) for the year 2012 across the different counties in Hunan. \n\nThe counties are shaded in varying colors, ranging from light to dark, to represent different GDP per capita ranges. Darker shades indicate higher GDP per capita values, while lighter shades represent lower values. This visualization helps to identify regional economic disparities and highlights areas with higher or lower economic activity within Hunan province.\n\nFor example, we can observe that Changsha has the highest GDP per capital values in the Hunan region.\n:::\n\n## Computing Contiguity Spatial Weights\n\nIn this section, we will use [*poly2nb()*](https://r-spatial.github.io/spdep/reference/poly2nb.html) of **spdep** package to compute contiguity weight matrices for the study area. This function builds a neighbours list based on regions with contiguous boundaries. \n\n::: callout-note\nContiguity means that two spatial units share a common border of non-zero length.\n\nOperationally, we can further distinguish between a **rook** and a **queen** criterion of contiguity, in analogy to the moves allowed for the such-named pieces on a chess board.\n\nThe rook criterion defines neighbors by the existence of a common edge between two spatial units. The queen criterion is somewhat more encompassing and defines neighbors as spatial units sharing a common edge or a common vertex.\n\nUsing `poly2nb()` we can use the `queen` flag to toggle between queen and rook criteria.\n\nFor more info, see [Chapter 6 Contiguity-Based Spatial Weights | Hands-On Spatial Data Science with R](https://spatialanalysis.github.io/handsonspatialdata/contiguity-based-spatial-weights.html)\n\n:::\n\n> The number of neighbors according to the queen criterion will always be at least as large as for the rook criterion.\n\n\nFirst, we will compute the Queen contiguity weight matrix.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nwm_q <- poly2nb(hunan, queen=TRUE)\nsummary(wm_q)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nNeighbour list object:\nNumber of regions: 88 \nNumber of nonzero links: 448 \nPercentage nonzero weights: 5.785124 \nAverage number of links: 5.090909 \nLink number distribution:\n\n 1  2  3  4  5  6  7  8  9 11 \n 2  2 12 16 24 14 11  4  2  1 \n2 least connected regions:\n30 65 with 1 link\n1 most connected region:\n85 with 11 links\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nwm_r <- poly2nb(hunan, queen=FALSE)\nsummary(wm_r)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nNeighbour list object:\nNumber of regions: 88 \nNumber of nonzero links: 440 \nPercentage nonzero weights: 5.681818 \nAverage number of links: 5 \nLink number distribution:\n\n 1  2  3  4  5  6  7  8  9 10 \n 2  2 12 20 21 14 11  3  2  1 \n2 least connected regions:\n30 65 with 1 link\n1 most connected region:\n85 with 10 links\n```\n\n\n:::\n:::\n\n\n\n::: callout-note\n**Intepretation of Summary Reports**\n\n1. Both reports shows that there are 88 area units in Hunan.\n\n2. As expected, the total number of links (neighbor relationships) is slightly higher for the queen criterion (448) than for the rook criterion (440).\n\n3. Based on both criteria, the most connected region is **Region 85** with 11 links (using Queen criteria) and 10 links (using Rook criteria)\n\n4.  Similarly, based on both criteria, the least connected region is **Region 30 and 65** with 1 links (using Queen and Rook criteria)\n:::\n\nFor each polygon in the polygon object, `wm_q` and `wm_r` lists all neighboring polygons. \nFor example, we can identify the most connected region.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncat(\"The most connected county is\", hunan$County[85])\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nThe most connected county is Taoyuan\n```\n\n\n:::\n:::\n\n\n\nTo reveal the county names of the neighboring polygons, we can do the following:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nneighbour_counties <- wm_q[[85]]\nprint(neighbour_counties)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1]  1  2  3  5  6 32 56 57 69 75 78\n```\n\n\n:::\n\n```{.r .cell-code}\ncat(\"Using Queen's method, the neighbours of \", hunan$County[85],\" is\", hunan$NAME_3[neighbour_counties])\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nUsing Queen's method, the neighbours of  Taoyuan  is Anxiang Hanshou Jinshi Linli Shimen Yuanling Anhua Nan Cili Sangzhi Taojiang\n```\n\n\n:::\n:::\n\n\n\nWe can also retrieve the GDPPC of these counties:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhunan$GDPPC[neighbour_counties]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1] 23667 20981 34592 25554 27137 24194 14567 21311 18714 14624 19509\n```\n\n\n:::\n:::\n\n\n\nThe printed output above shows that the GDPPC of Taoyuan's neighbouring counties.\n\nTo display the complete weight matrix, we can use `str()`.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstr(wm_q)\n```\n:::\n\n\n\n## Visualising Contiguity Weights\n\nTo create a connectivity graph, we need points that represent each polygon, and we'll draw lines to connect neighboring points. Since we're working with polygons, we first need to find their central points, called **centroids**. We'll calculate these centroids using the **sf** package before creating the connectivity graph.\n\n**Getting Latitude and Longitude of Polygon Centroids**\n\nTo make the connectivity graph, we must first obtain the points (centroids) for each polygon. This is more than just running `st_centroid` on our spatial object (`us.bound`). We need to store the coordinates in a separate data frame. \n\nWe'll use a mapping function to achieve this. The mapping function applies a specific function to each element in a vector and returns a vector of the same length. In this case, our input vector will be the geometry column of `us.bound`, and the function will be `st_centroid`. We'll use the `map_dbl` function from the **purrr** package to do this.\n\nFor longitude, we access the first coordinate value using [[1]], and for latitude, we access the second coordinate value using [[2]].\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlongitude <- map_dbl(hunan$geometry, ~st_centroid(.x)[[1]])\nlatitude <- map_dbl(hunan$geometry, ~st_centroid(.x)[[2]])\n```\n:::\n\n\n\nThen, we use `cbind()` to combine longitude and lattude into the same object.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncoords <- cbind(longitude, latitude)\n```\n:::\n\n\n\n\nTo verify that, the data is formatted correctly, we can observe the first few instances.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhead(coords)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     longitude latitude\n[1,]  112.1531 29.44362\n[2,]  112.0372 28.86489\n[3,]  111.8917 29.47107\n[4,]  111.7031 29.74499\n[5,]  111.6138 29.49258\n[6,]  111.0341 29.79863\n```\n\n\n:::\n:::\n\n\nTo plot the continguity-based neighbours map, we can do the following:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\npar(mfrow=c(1,2))\n\nplot(hunan$geometry, \n     main=\"Queen Contiguity\")\nplot(wm_q, \n     coords, \n     pch = 19, \n     cex = 0.6, \n     add = TRUE, \n     col= \"red\")\n\nplot(hunan$geometry, \n     main=\"Rook Contiguity\")\nplot(wm_r, \n     coords, \n     pch = 19, \n     cex = 0.6, \n     add = TRUE, \n     col = \"red\")\n```\n\n::: {.cell-output-display}\n![](Hands-on_Ex04a_files/figure-html/unnamed-chunk-21-1.png){width=1152}\n:::\n:::\n\n\n\n![](img/queen-vs-rook.png)\n::: callout-note\nAs observed from the previous sections, we understand that more links will be formed with the Queen's method. This is evident in the plot above.Some of these differences has been marked with blue boxes for better visualization.\n:::\n\n## Computing Distance-based Neighbours\n\nIn this section, we will create distance-based weight matrices using the [`dnearneigh()`](https://r-spatial.github.io/spdep/reference/dnearneigh.html) function from the **spdep** package.\n\nThis function identifies neighboring region points based on their Euclidean distance. We can specify a range for the distances using the `bounds` argument, which takes lower (`d1=`) and upper (`d2=`) limits. \n\nIf the coordinates are not projected (i.e., in latitude and longitude) and are specified in the `x` object or provided as a two-column matrix with `longlat=TRUE`, the function will calculate great circle distances in kilometers, assuming the WGS84 reference ellipsoid.\n\n### Determine the Cut-off Distance\n\nFirstly, we need to determine the upper limit for distance band by using the steps below:\n\n1. Use the [`knearneigh()`](https://r-spatial.github.io/spdep/reference/knearneigh.html) function from the **spdep** package to create a matrix with the indices of the k nearest neighbors for each point.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# get k nearest neighbour where k = 1 (default)\nknearneigh(coords, k=1)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n$nn\n      [,1]\n [1,]    3\n [2,]   78\n [3,]    1\n [4,]    5\n [5,]    4\n [6,]   69\n [7,]   67\n [8,]   46\n [9,]   84\n[10,]   70\n[11,]   72\n[12,]   63\n[13,]   12\n[14,]   17\n[15,]   13\n[16,]   22\n[17,]   16\n[18,]   20\n[19,]   21\n[20,]   82\n[21,]   19\n[22,]   16\n[23,]   41\n[24,]   54\n[25,]   81\n[26,]   81\n[27,]   29\n[28,]   49\n[29,]   27\n[30,]   33\n[31,]   24\n[32,]   50\n[33,]   28\n[34,]   45\n[35,]   47\n[36,]   34\n[37,]   42\n[38,]   44\n[39,]   43\n[40,]   39\n[41,]   23\n[42,]   37\n[43,]   44\n[44,]   43\n[45,]   34\n[46,]   47\n[47,]   46\n[48,]   51\n[49,]   28\n[50,]   52\n[51,]   48\n[52,]   54\n[53,]   55\n[54,]   52\n[55,]   50\n[56,]   36\n[57,]   58\n[58,]   57\n[59,]   87\n[60,]   13\n[61,]   63\n[62,]   61\n[63,]   12\n[64,]   57\n[65,]   76\n[66,]   68\n[67,]    7\n[68,]   66\n[69,]    6\n[70,]   10\n[71,]   74\n[72,]   11\n[73,]   70\n[74,]   71\n[75,]   55\n[76,]   65\n[77,]   38\n[78,]    2\n[79,]   45\n[80,]   34\n[81,]   25\n[82,]   21\n[83,]   12\n[84,]    9\n[85,]    5\n[86,]   74\n[87,]   61\n[88,]   87\n\n$np\n[1] 88\n\n$k\n[1] 1\n\n$dimension\n[1] 2\n\n$x\n      longitude latitude\n [1,]  112.1531 29.44362\n [2,]  112.0372 28.86489\n [3,]  111.8917 29.47107\n [4,]  111.7031 29.74499\n [5,]  111.6138 29.49258\n [6,]  111.0341 29.79863\n [7,]  113.7065 28.23215\n [8,]  112.3460 28.13081\n [9,]  112.8169 28.28918\n[10,]  113.3534 26.57906\n[11,]  113.8942 25.98122\n[12,]  112.4006 25.63215\n[13,]  112.5542 25.33880\n[14,]  113.6636 25.54967\n[15,]  112.9206 25.26722\n[16,]  113.1883 26.21248\n[17,]  113.4521 25.93480\n[18,]  112.4209 26.36132\n[19,]  113.0152 27.08120\n[20,]  112.6350 26.75969\n[21,]  112.7087 27.27930\n[22,]  112.9095 26.42079\n[23,]  111.9522 26.80117\n[24,]  110.2606 27.89384\n[25,]  110.0921 27.54115\n[26,]  109.7985 26.91321\n[27,]  109.5765 26.54507\n[28,]  109.7211 27.78801\n[29,]  109.7339 26.21157\n[30,]  109.1537 27.22941\n[31,]  110.6442 27.83407\n[32,]  110.5916 28.57282\n[33,]  109.5984 27.39828\n[34,]  111.4783 27.67997\n[35,]  112.1745 27.46256\n[36,]  111.2315 27.86930\n[37,]  110.3149 26.32113\n[38,]  111.3248 26.48991\n[39,]  110.5859 27.10164\n[40,]  110.9593 27.34884\n[41,]  111.8296 27.18765\n[42,]  110.1926 26.70972\n[43,]  110.7334 26.78494\n[44,]  110.9123 26.54354\n[45,]  111.4599 27.42910\n[46,]  112.5268 27.92456\n[47,]  112.3406 27.77407\n[48,]  109.5602 28.66808\n[49,]  109.5071 28.01142\n[50,]  109.9954 28.60033\n[51,]  109.4273 28.42749\n[52,]  109.7587 28.31518\n[53,]  109.5044 29.21940\n[54,]  109.9899 28.16053\n[55,]  109.9664 29.01206\n[56,]  111.3785 28.28449\n[57,]  112.4350 29.23817\n[58,]  112.5558 28.97135\n[59,]  111.7379 24.97087\n[60,]  112.1831 25.31559\n[61,]  111.9743 25.65101\n[62,]  111.7009 25.91101\n[63,]  112.2196 25.88615\n[64,]  112.6472 29.48614\n[65,]  113.5102 29.49285\n[66,]  113.1172 28.79707\n[67,]  113.7089 28.76024\n[68,]  112.7963 28.71653\n[69,]  110.9276 29.39439\n[70,]  113.6420 26.80361\n[71,]  113.4577 27.66123\n[72,]  113.8404 26.37989\n[73,]  113.4758 27.17064\n[74,]  113.1428 27.62875\n[75,]  110.3017 29.39053\n[76,]  113.1957 29.25343\n[77,]  111.7410 26.36035\n[78,]  112.1831 28.49854\n[79,]  111.3390 27.01465\n[80,]  111.8208 27.75124\n[81,]  110.0753 27.23539\n[82,]  112.3965 27.08323\n[83,]  112.7683 25.82828\n[84,]  113.1679 28.30074\n[85,]  111.4495 28.95406\n[86,]  112.7956 27.68910\n[87,]  111.5896 25.49530\n[88,]  111.2393 25.19355\n\nattr(,\"class\")\n[1] \"knn\"\nattr(,\"call\")\nknearneigh(x = coords, k = 1)\n```\n\n\n:::\n:::\n\n\n2. Convert the `knn` object returned by `knearneigh()` into a neighbor list (`nb` class) using the [`knn2nb()`](https://r-spatial.github.io/spdep/reference/knn2nb.html) function. This list contains integer vectors representing the IDs of neighboring regions.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# convert knn matrix to neighbour list for k = 1\nk1 <- knn2nb(knearneigh(coords))\nk1\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nNeighbour list object:\nNumber of regions: 88 \nNumber of nonzero links: 88 \nPercentage nonzero weights: 1.136364 \nAverage number of links: 1 \n25 disjoint connected subgraphs\nNon-symmetric neighbours list\n```\n\n\n:::\n:::\n\n\n3. Calculate the length of neighbor relationship edges with the [`nbdists()`](https://r-spatial.github.io/spdep/reference/nbdists.html) function from **spdep**. The distances will be in the units of the coordinates if projected, or in kilometers if not.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnbdists(k1, coords, longlat = TRUE)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[[1]]\n[1] 25.53398\n\n[[2]]\n[1] 43.03114\n\n[[3]]\n[1] 25.53398\n\n[[4]]\n[1] 29.2848\n\n[[5]]\n[1] 29.2848\n\n[[6]]\n[1] 45.98097\n\n[[7]]\n[1] 58.52704\n\n[[8]]\n[1] 28.95985\n\n[[9]]\n[1] 34.45062\n\n[[10]]\n[1] 37.99885\n\n[[11]]\n[1] 44.49442\n\n[[12]]\n[1] 33.48816\n\n[[13]]\n[1] 35.98123\n\n[[14]]\n[1] 47.65184\n\n[[15]]\n[1] 37.73556\n\n[[16]]\n[1] 36.16613\n\n[[17]]\n[1] 40.53569\n\n[[18]]\n[1] 49.02492\n\n[[19]]\n[1] 37.47543\n\n[[20]]\n[1] 42.97316\n\n[[21]]\n[1] 37.47543\n\n[[22]]\n[1] 36.16613\n\n[[23]]\n[1] 44.51898\n\n[[24]]\n[1] 39.7744\n\n[[25]]\n[1] 33.9218\n\n[[26]]\n[1] 45.03425\n\n[[27]]\n[1] 40.15056\n\n[[28]]\n[1] 32.50795\n\n[[29]]\n[1] 40.15056\n\n[[30]]\n[1] 47.83345\n\n[[31]]\n[1] 38.35439\n\n[[32]]\n[1] 58.39365\n\n[[33]]\n[1] 44.85211\n\n[[34]]\n[1] 27.85864\n\n[[35]]\n[1] 38.2151\n\n[[36]]\n[1] 32.12293\n\n[[37]]\n[1] 44.74688\n\n[[38]]\n[1] 41.53815\n\n[[39]]\n[1] 38.02669\n\n[[40]]\n[1] 46.029\n\n[[41]]\n[1] 44.51898\n\n[[42]]\n[1] 44.74688\n\n[[43]]\n[1] 32.1334\n\n[[44]]\n[1] 32.1334\n\n[[45]]\n[1] 27.85864\n\n[[46]]\n[1] 24.79082\n\n[[47]]\n[1] 24.79082\n\n[[48]]\n[1] 29.66852\n\n[[49]]\n[1] 32.50795\n\n[[50]]\n[1] 39.19375\n\n[[51]]\n[1] 29.66852\n\n[[52]]\n[1] 28.43598\n\n[[53]]\n[1] 50.50645\n\n[[54]]\n[1] 28.43598\n\n[[55]]\n[1] 45.721\n\n[[56]]\n[1] 48.22649\n\n[[57]]\n[1] 31.82332\n\n[[58]]\n[1] 31.82332\n\n[[59]]\n[1] 59.98421\n\n[[60]]\n[1] 37.44866\n\n[[61]]\n[1] 35.83248\n\n[[62]]\n[1] 39.77577\n\n[[63]]\n[1] 33.48816\n\n[[64]]\n[1] 34.34758\n\n[[65]]\n[1] 40.45791\n\n[[66]]\n[1] 32.58547\n\n[[67]]\n[1] 58.52704\n\n[[68]]\n[1] 32.58547\n\n[[69]]\n[1] 45.98097\n\n[[70]]\n[1] 37.99885\n\n[[71]]\n[1] 31.27538\n\n[[72]]\n[1] 44.49442\n\n[[73]]\n[1] 43.88878\n\n[[74]]\n[1] 31.27538\n\n[[75]]\n[1] 53.12656\n\n[[76]]\n[1] 40.45791\n\n[[77]]\n[1] 43.93382\n\n[[78]]\n[1] 43.03114\n\n[[79]]\n[1] 47.45858\n\n[[80]]\n[1] 34.68711\n\n[[81]]\n[1] 33.9218\n\n[[82]]\n[1] 37.80739\n\n[[83]]\n[1] 42.81869\n\n[[84]]\n[1] 34.45062\n\n[[85]]\n[1] 61.79116\n\n[[86]]\n[1] 34.90929\n\n[[87]]\n[1] 42.32891\n\n[[88]]\n[1] 48.59005\n\nattr(,\"class\")\n[1] \"nbdist\"\nattr(,\"call\")\nnbdists(nb = k1, coords = coords, longlat = TRUE)\n```\n\n\n:::\n:::\n\n\n\n\n4. Simplify the list structure of the returned object using the [`unlist()`](https://www.rdocumentation.org/packages/base/versions/3.6.2/topics/unlist) function from the base R package.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nk1dists <- unlist(nbdists(k1, coords, longlat = TRUE))\nsummary(k1dists)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \n  24.79   32.57   38.01   39.07   44.52   61.79 \n```\n\n\n:::\n:::\n\n\n\n::: callout-note\nUsing the summary report, we can observe that the largest first nearest neighbour distance is 61.79 km, so using this as the upper threshold gives certainty that all units will have at least one neighbour.\n:::\n\n### Plotting Fixed Distance Weight Matrix\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# get max dist from k1dists rounded up to integer\nmax_dist <- as.integer(ceiling(max(k1dists)))\n\nwm_d62 <- dnearneigh(x=coords, d1=0, d2=max_dist, longlat = TRUE)\nwm_d62\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nNeighbour list object:\nNumber of regions: 88 \nNumber of nonzero links: 324 \nPercentage nonzero weights: 4.183884 \nAverage number of links: 3.681818 \n```\n\n\n:::\n:::\n\n\n::: callout-note\n**Output Intepretation**\n\n1. The weight matrix shows 88 regions (counties).\n2. There are a total of 324 connections between all regions. \n3. The formula for **Percentage nonzero weights**:\n\n$\\text{Percentage nonzero weights} = \\left( \\frac{\\text{Number of nonzero links}}{\\text{Total possible links}} \\right) \\times 100$\n\nand the total possible links can be computed as $n \\times n=88 \\times 88 = 7744$\n\nPlugging in the numbers, we will get $\\text{Percentage nonzero weights} = \\left( \\frac{324}{7744} \\right) \\times 100 \\approx 4.18\\%$\n\n4. The formula for average number of links:   $\\text{Average number of links} = \\frac{\\text{Total number of nonzero links}}{\\text{Number of regions}} = \\frac{324}{88} \\approx 3.68$\n:::\n\nWe can also use `str()` to display the content of `wm_d62` weight matrix.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstr(wm_d62)\n```\n:::\n\n\nAnother way to display the structure of the weight matrix is to combine [`table()`](https://www.rdocumentation.org/packages/base/versions/3.6.2/topics/table) and [`card()`](https://r-spatial.github.io/spdep/reference/card.html) of **spdep**.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntable(hunan$County, \n      card(wm_d62))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n               \n                1 2 3 4 5 6\n  Anhua         1 0 0 0 0 0\n  Anren         0 0 0 1 0 0\n  Anxiang       0 0 0 0 1 0\n  Baojing       0 0 0 0 1 0\n  Chaling       0 0 1 0 0 0\n  Changning     0 0 1 0 0 0\n  Changsha      0 0 0 1 0 0\n  Chengbu       0 1 0 0 0 0\n  Chenxi        0 0 0 1 0 0\n  Cili          0 1 0 0 0 0\n  Dao           0 0 0 1 0 0\n  Dongan        0 0 1 0 0 0\n  Dongkou       0 0 0 1 0 0\n  Fenghuang     0 0 0 1 0 0\n  Guidong       0 0 1 0 0 0\n  Guiyang       0 0 0 1 0 0\n  Guzhang       0 0 0 0 0 1\n  Hanshou       0 0 0 1 0 0\n  Hengdong      0 0 0 0 1 0\n  Hengnan       0 0 0 0 1 0\n  Hengshan      0 0 0 0 0 1\n  Hengyang      0 0 0 0 0 1\n  Hongjiang     0 0 0 0 1 0\n  Huarong       0 0 0 1 0 0\n  Huayuan       0 0 0 1 0 0\n  Huitong       0 0 0 1 0 0\n  Jiahe         0 0 0 0 1 0\n  Jianghua      0 0 1 0 0 0\n  Jiangyong     0 1 0 0 0 0\n  Jingzhou      0 1 0 0 0 0\n  Jinshi        0 0 0 1 0 0\n  Jishou        0 0 0 0 0 1\n  Lanshan       0 0 0 1 0 0\n  Leiyang       0 0 0 1 0 0\n  Lengshuijiang 0 0 1 0 0 0\n  Li            0 0 1 0 0 0\n  Lianyuan      0 0 0 0 1 0\n  Liling        0 1 0 0 0 0\n  Linli         0 0 0 1 0 0\n  Linwu         0 0 0 1 0 0\n  Linxiang      1 0 0 0 0 0\n  Liuyang       0 1 0 0 0 0\n  Longhui       0 0 1 0 0 0\n  Longshan      0 1 0 0 0 0\n  Luxi          0 0 0 0 1 0\n  Mayang        0 0 0 0 0 1\n  Miluo         0 0 0 0 1 0\n  Nan           0 0 0 0 1 0\n  Ningxiang     0 0 0 1 0 0\n  Ningyuan      0 0 0 0 1 0\n  Pingjiang     0 1 0 0 0 0\n  Qidong        0 0 1 0 0 0\n  Qiyang        0 0 1 0 0 0\n  Rucheng       0 1 0 0 0 0\n  Sangzhi       0 1 0 0 0 0\n  Shaodong      0 0 0 0 1 0\n  Shaoshan      0 0 0 0 1 0\n  Shaoyang      0 0 0 1 0 0\n  Shimen        1 0 0 0 0 0\n  Shuangfeng    0 0 0 0 0 1\n  Shuangpai     0 0 0 1 0 0\n  Suining       0 0 0 0 1 0\n  Taojiang      0 1 0 0 0 0\n  Taoyuan       0 1 0 0 0 0\n  Tongdao       0 1 0 0 0 0\n  Wangcheng     0 0 0 1 0 0\n  Wugang        0 0 1 0 0 0\n  Xiangtan      0 0 0 1 0 0\n  Xiangxiang    0 0 0 0 1 0\n  Xiangyin      0 0 0 1 0 0\n  Xinhua        0 0 0 0 1 0\n  Xinhuang      1 0 0 0 0 0\n  Xinning       0 1 0 0 0 0\n  Xinshao       0 0 0 0 0 1\n  Xintian       0 0 0 0 1 0\n  Xupu          0 1 0 0 0 0\n  Yanling       0 0 1 0 0 0\n  Yizhang       1 0 0 0 0 0\n  Yongshun      0 0 0 1 0 0\n  Yongxing      0 0 0 1 0 0\n  You           0 0 0 1 0 0\n  Yuanjiang     0 0 0 0 1 0\n  Yuanling      1 0 0 0 0 0\n  Yueyang       0 0 1 0 0 0\n  Zhijiang      0 0 0 0 1 0\n  Zhongfang     0 0 0 1 0 0\n  Zhuzhou       0 0 0 0 1 0\n  Zixing        0 0 1 0 0 0\n```\n\n\n:::\n:::\n\n\n`n.comp.nb()` finds the number of disjoint connected subgraphs in the graph depicted by `nb.obj`\nsee [Graph Components function - RDocumentation](https://www.rdocumentation.org/packages/spdep/versions/0.1-9/topics/Graph%20Components)\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nn_comp <- n.comp.nb(wm_d62)\nn_comp$nc\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1\n```\n\n\n:::\n:::\n\n\n\nAbove shows the number of connected components in the spatial neighbour network. The output of 1 indicates that is 1 connected component.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntable(n_comp$comp.id)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\n 1 \n88 \n```\n\n\n:::\n:::\n\n\n\nAnd this connected component comprises of 88 regions, indicating all regions are part of a single interconnected group.\n\n### Plotting Fixed Distance Weight Matrix\n\nWe can plot the distance weight matrix as shown below:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\npar(mfrow=c(1,2))\n\nplot(hunan$geometry, border=\"lightgrey\", main=\"1st Nearest Neighbours\")\nplot(k1, coords, add=TRUE, col=\"red\", length=0.08)\n\nplot(hunan$geometry, border=\"lightgrey\", main=\"Distance Link\")\nplot(wm_d62, coords, add=TRUE)\nplot(k1, coords, add=TRUE, col=\"red\", length=0.08)\n```\n\n::: {.cell-output-display}\n![](Hands-on_Ex04a_files/figure-html/unnamed-chunk-31-1.png){width=768}\n:::\n:::\n\n\nOn the left plot, the red lines show the links of 1st nearest neighbours.\n\nOn the right plot, the red lines show the links of 1st nearest neighbours and the black lines show the links of neighbours within the cut-off distance of 62km.\n\n### Computing Adaptive Distance Weight Matrix\n\nA fixed distance weight matrix typically shows that densely populated areas (like urban regions) have more neighbors, while sparsely populated areas (such as rural counties) have fewer neighbors. When there are many neighbors, the relationships between them are spread across a larger number of connections, creating a smoother effect.\n\nTo control the number of neighbours, we can set the `k` value.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nknn6 <- knn2nb(knearneigh(coords, k=6))\nknn6\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nNeighbour list object:\nNumber of regions: 88 \nNumber of nonzero links: 528 \nPercentage nonzero weights: 6.818182 \nAverage number of links: 6 \nNon-symmetric neighbours list\n```\n\n\n:::\n:::\n\n\n\nEach county has exactly 6 neighbours.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstr(knn6)\n```\n:::\n\n\n\n#### Computing Adaptive Distance Weight Matrix\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nplot(hunan$geometry, border=\"lightgrey\", main=\"6 Nearest Neighbours\")\nplot(knn6, coords, add = TRUE, col = \"red\")\n```\n\n::: {.cell-output-display}\n![](Hands-on_Ex04a_files/figure-html/unnamed-chunk-34-1.png){width=768}\n:::\n:::\n\n\n\n## Weights based on Inversed Distance Weight (IDW) Method\n\nIn this section, you will learn how to derive a spatial weight matrix based on Inversed Distance Weights method.\n\n::: callout-note\nIn order to conform to Tobler’s first law of geography, a distance decay effect must be respected.\n\nThe inverse distance weight method assigns weights to neighbors based on their distance: closer neighbors get higher weights, and further ones get lower weights.\n\nIt works by taking the distance between two locations and calculating the weight as 1 divided by that distance. \n\nFor more info, see [Spatial Weights as Distance Functions](https://spatialanalysis.github.io/lab_tutorials/Spatial_Weights_as_Distance_Functions.html#creating-inverse-distance-functions-for-distance-bands).\n\n:::\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndist <- nbdists(wm_q, \n                coords, \n                longlat = TRUE)\n# apply 1/x on every element on list objects\nids <- lapply(dist, function(x) 1/(x))\n```\n:::\n\n\n\n## Row-standardised Weights Matrix\n\nNext, we need to assign weights to each neighboring polygon. In this case, we'll use equal weights (style=\"W\"), where each neighboring polygon gets a weight of **1/(number of neighbors)**. This means we take the value for each neighbor and divide it by the total number of neighbors, then sum these weighted values to calculate a summary measure, such as weighted income.\n\nWhile this equal weighting approach is straightforward and easy to understand, it has a limitation: **polygons on the edges of the study area have fewer neighbors, which can lead to over- or underestimation of the actual spatial relationships (spatial autocorrelation) in the data.**\n\n::: callout-tip\nFor simplicity, we use the style=\"W\" option in this example, but keep in mind that other, potentially more accurate methods are available, such as style=\"B\".\n:::\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# note we are using queen's method here\nrswm_q <- nb2listw(wm_q, style=\"W\", zero.policy = TRUE)\nrswm_q\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nCharacteristics of weights list object:\nNeighbour list object:\nNumber of regions: 88 \nNumber of nonzero links: 448 \nPercentage nonzero weights: 5.785124 \nAverage number of links: 5.090909 \n\nWeights style: W \nWeights constants summary:\n   n   nn S0       S1       S2\nW 88 7744 88 37.86334 365.9147\n```\n\n\n:::\n:::\n\n\n\n::: callout-tip\nThe zero.policy=TRUE option allows for lists of non-neighbors. This should be used with caution since the user may not be aware of missing neighbors in their dataset however, a zero.policy of FALSE would return an error.\n:::\n\nTo see the weight of the 85th polygon’s 11 neighbors type:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrswm_q$weights[85]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[[1]]\n [1] 0.09090909 0.09090909 0.09090909 0.09090909 0.09090909 0.09090909\n [7] 0.09090909 0.09090909 0.09090909 0.09090909 0.09090909\n```\n\n\n:::\n:::\n\n\nEach neighbor is assigned a 0.0909 of the total weight. This means that when R computes the average neighboring income values, each neighbor’s income will be multiplied by 0.0909 before being tallied.\n\nUsing the same method, we can also derive a row standardised distance weight matrix by using the code block below.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrswm_ids <- nb2listw(wm_q, glist=ids, style=\"B\", zero.policy=TRUE)\nrswm_ids\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nCharacteristics of weights list object:\nNeighbour list object:\nNumber of regions: 88 \nNumber of nonzero links: 448 \nPercentage nonzero weights: 5.785124 \nAverage number of links: 5.090909 \n\nWeights style: B \nWeights constants summary:\n   n   nn       S0        S1     S2\nB 88 7744 8.786867 0.3776535 3.8137\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nrswm_ids$weights[85]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[[1]]\n [1] 0.011451133 0.017193502 0.013957649 0.016183544 0.009810297 0.010656545\n [7] 0.013416965 0.009903702 0.014199260 0.008217581 0.011407794\n```\n\n\n:::\n:::\n\n\n\nNotice that the output has different weight of each neighbour. We can use summary report to observe the differences.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsummary(unlist(rswm_q$weights))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \n0.09091 0.14286 0.20000 0.19643 0.20000 1.00000 \n```\n\n\n:::\n\n```{.r .cell-code}\ncat(\"\\n-----------------------------\\n\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\n-----------------------------\n```\n\n\n:::\n\n```{.r .cell-code}\nsummary(unlist(rswm_ids$weights))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n    Min.  1st Qu.   Median     Mean  3rd Qu.     Max. \n0.008218 0.015088 0.018739 0.019614 0.022823 0.040338 \n```\n\n\n:::\n:::\n\n\n## Application of Spatial Weight Matrix\n\nIn this section, we will create 4 different spatial lagged variables:\n\n1. spatial lag with row-standardized weights,\n2. spatial lag as a sum of neighbouring values,\n3. spatial window average, and\n4. spatial window sum.\n\n### Spatial Lag with Row-standardized Weights\n\nWe’ll compute the average neighbor GDPPC value for each polygon. These values are often referred to as **spatially lagged values**.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nGDPPC.lag <- lag.listw(rswm_q, hunan$GDPPC)\nGDPPC.lag\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1] 24847.20 22724.80 24143.25 27737.50 27270.25 21248.80 43747.00 33582.71\n [9] 45651.17 32027.62 32671.00 20810.00 25711.50 30672.33 33457.75 31689.20\n[17] 20269.00 23901.60 25126.17 21903.43 22718.60 25918.80 20307.00 20023.80\n[25] 16576.80 18667.00 14394.67 19848.80 15516.33 20518.00 17572.00 15200.12\n[33] 18413.80 14419.33 24094.50 22019.83 12923.50 14756.00 13869.80 12296.67\n[41] 15775.17 14382.86 11566.33 13199.50 23412.00 39541.00 36186.60 16559.60\n[49] 20772.50 19471.20 19827.33 15466.80 12925.67 18577.17 14943.00 24913.00\n[57] 25093.00 24428.80 17003.00 21143.75 20435.00 17131.33 24569.75 23835.50\n[65] 26360.00 47383.40 55157.75 37058.00 21546.67 23348.67 42323.67 28938.60\n[73] 25880.80 47345.67 18711.33 29087.29 20748.29 35933.71 15439.71 29787.50\n[81] 18145.00 21617.00 29203.89 41363.67 22259.09 44939.56 16902.00 16930.00\n```\n\n\n:::\n:::\n\n\nIn the previous section, we retrieved the GDPPC of these 11 counties by using the code block below.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnb1 <- wm_q[[85]]\nnb1 <- hunan$GDPPC[nb1]\nnb1\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1] 23667 20981 34592 25554 27137 24194 14567 21311 18714 14624 19509\n```\n\n\n:::\n:::\n\n\n\n> Question: Can you see the meaning of Spatial lag with row-standardized weights now?\n> Spatial lag represents the average or sum of a variable (GDPPC) for a region's neighbors. In this context, the spatial lag for a region gives an idea of how that region's GDPPC relates to the GDPPC of its neighboring regions.\n>\n> With row-standardized weights (style=\"W\"), each neighboring region is assigned an equal weight of 1/(number of neighbors). This ensures that the weights for all neighbors of a region sum to 1.\n\nWe can append the spatially lag GDPPC values onto hunan sf data frame by using the code block below:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlag.list <- list(hunan$NAME_3, lag.listw(rswm_q, hunan$GDPPC))\nlag.res <- as.data.frame(lag.list)\ncolnames(lag.res) <- c(\"NAME_3\", \"lag GDPPC\")\nhunan <- left_join(hunan,lag.res)\n```\n:::\n\n\n\nThe following table shows the average neighboring income values (stored in the Inc.lag object) for each county.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhead(hunan)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nSimple feature collection with 6 features and 7 fields\nGeometry type: POLYGON\nDimension:     XY\nBounding box:  xmin: 110.4922 ymin: 28.61762 xmax: 112.3013 ymax: 30.12812\nGeodetic CRS:  WGS 84\n   NAME_2  ID_3  NAME_3   ENGTYPE_3  County GDPPC lag GDPPC\n1 Changde 21098 Anxiang      County Anxiang 23667  24847.20\n2 Changde 21100 Hanshou      County Hanshou 20981  22724.80\n3 Changde 21101  Jinshi County City  Jinshi 34592  24143.25\n4 Changde 21102      Li      County      Li 24473  27737.50\n5 Changde 21103   Linli      County   Linli 25554  27270.25\n6 Changde 21104  Shimen      County  Shimen 27137  21248.80\n                        geometry\n1 POLYGON ((112.0625 29.75523...\n2 POLYGON ((112.2288 29.11684...\n3 POLYGON ((111.8927 29.6013,...\n4 POLYGON ((111.3731 29.94649...\n5 POLYGON ((111.6324 29.76288...\n6 POLYGON ((110.8825 30.11675...\n```\n\n\n:::\n:::\n\n\nNext, we will plot both the GDPPC and spatial lag GDPPC for comparison using the code block below.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngdppc <- qtm(hunan, \"GDPPC\")\nlag_gdppc <- qtm(hunan, \"lag GDPPC\")\ntmap_arrange(gdppc, lag_gdppc, asp=1, ncol=2)\n```\n\n::: {.cell-output-display}\n![](Hands-on_Ex04a_files/figure-html/unnamed-chunk-45-1.png){width=672}\n:::\n:::\n\n\n\nRecall that in our previous observation, we made the statement that Changsha has the highest GDP per capital values in the Hunan region.\n\nUsing spatial lag values, we can observe that Yueyang has the *highest spatial lag GDP per capita, meaning its neighbors (on average) have the highest GDP per capita.*\n\n### Spatial Lag as a Sum of Neighboring Values\n\nTo calculate spatial lag as the sum of neighboring values, we can assign binary weights (where each neighbor gets a weight of 1). \n\nTo do this, we go back to our list of neighbors and use a function to assign these binary weights. We then use the `glist` argument in the `nb2listw` function to set these weights explicitly.\n\nWe start by using `lapply` to assign a weight of 1 to each neighbor. `lapply` is a function we have been using to work with the neighbors list in previous notebooks; it applies a specified function to each value in the neighbors list.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Create binary weights for each neighbor\n# uses lapply to go through each element of the neighbors list (wm_q).\n# The function '0 * x + 1' assigns a weight of 1 to each neighbor.\nb_weights <- lapply(wm_q, function(x) 0*x + 1)\n\n# Convert the neighbor list to a spatial weights list object\n# 'nb2listw' converts the neighbors list (wm_q) into a weights list.\n# 'glist = b_weights' explicitly sets the weights to the binary weights created above.\n# 'style = \"B\"' specifies binary weighting style, where each neighbor has equal weight (1).\nb_weights2 <- nb2listw(wm_q, \n                       glist = b_weights, \n                       style = \"B\")\nb_weights2\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nCharacteristics of weights list object:\nNeighbour list object:\nNumber of regions: 88 \nNumber of nonzero links: 448 \nPercentage nonzero weights: 5.785124 \nAverage number of links: 5.090909 \n\nWeights style: B \nWeights constants summary:\n   n   nn  S0  S1    S2\nB 88 7744 448 896 10224\n```\n\n\n:::\n:::\n\n\n\nWith the proper weights assigned, we can use `lag.listw` to compute a lag variable from our weight and GDPPC.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlag_sum <- list(hunan$NAME_3, lag.listw(b_weights2, hunan$GDPPC))\nlag.res <- as.data.frame(lag_sum)\ncolnames(lag.res) <- c(\"NAME_3\", \"lag_sum GDPPC\")\nlag_sum\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[[1]]\n [1] \"Anxiang\"       \"Hanshou\"       \"Jinshi\"        \"Li\"           \n [5] \"Linli\"         \"Shimen\"        \"Liuyang\"       \"Ningxiang\"    \n [9] \"Wangcheng\"     \"Anren\"         \"Guidong\"       \"Jiahe\"        \n[13] \"Linwu\"         \"Rucheng\"       \"Yizhang\"       \"Yongxing\"     \n[17] \"Zixing\"        \"Changning\"     \"Hengdong\"      \"Hengnan\"      \n[21] \"Hengshan\"      \"Leiyang\"       \"Qidong\"        \"Chenxi\"       \n[25] \"Zhongfang\"     \"Huitong\"       \"Jingzhou\"      \"Mayang\"       \n[29] \"Tongdao\"       \"Xinhuang\"      \"Xupu\"          \"Yuanling\"     \n[33] \"Zhijiang\"      \"Lengshuijiang\" \"Shuangfeng\"    \"Xinhua\"       \n[37] \"Chengbu\"       \"Dongan\"        \"Dongkou\"       \"Longhui\"      \n[41] \"Shaodong\"      \"Suining\"       \"Wugang\"        \"Xinning\"      \n[45] \"Xinshao\"       \"Shaoshan\"      \"Xiangxiang\"    \"Baojing\"      \n[49] \"Fenghuang\"     \"Guzhang\"       \"Huayuan\"       \"Jishou\"       \n[53] \"Longshan\"      \"Luxi\"          \"Yongshun\"      \"Anhua\"        \n[57] \"Nan\"           \"Yuanjiang\"     \"Jianghua\"      \"Lanshan\"      \n[61] \"Ningyuan\"      \"Shuangpai\"     \"Xintian\"       \"Huarong\"      \n[65] \"Linxiang\"      \"Miluo\"         \"Pingjiang\"     \"Xiangyin\"     \n[69] \"Cili\"          \"Chaling\"       \"Liling\"        \"Yanling\"      \n[73] \"You\"           \"Zhuzhou\"       \"Sangzhi\"       \"Yueyang\"      \n[77] \"Qiyang\"        \"Taojiang\"      \"Shaoyang\"      \"Lianyuan\"     \n[81] \"Hongjiang\"     \"Hengyang\"      \"Guiyang\"       \"Changsha\"     \n[85] \"Taoyuan\"       \"Xiangtan\"      \"Dao\"           \"Jiangyong\"    \n\n[[2]]\n [1] 124236 113624  96573 110950 109081 106244 174988 235079 273907 256221\n[11]  98013 104050 102846  92017 133831 158446 141883 119508 150757 153324\n[21] 113593 129594 142149 100119  82884  74668  43184  99244  46549  20518\n[31] 140576 121601  92069  43258 144567 132119  51694  59024  69349  73780\n[41]  94651 100680  69398  52798 140472 118623 180933  82798  83090  97356\n[51]  59482  77334  38777 111463  74715 174391 150558 122144  68012  84575\n[61] 143045  51394  98279  47671  26360 236917 220631 185290  64640  70046\n[71] 126971 144693 129404 284074 112268 203611 145238 251536 108078 238300\n[81] 108870 108085 262835 248182 244850 404456  67608  33860\n```\n\n\n:::\n:::\n\n\n\n> Question: Can you understand the meaning of Spatial lag as a sum of neighboring values now?\n>\n> By assigning binary weights (where each neighbor is given a weight of 1), we calculate the spatial lag by summing the values of this variable for all neighbors. \n> This means that the spatial lag reflects the combined influence or total value contributed by the neighboring regions, providing an idea of the overall regional context or neighborhood effect around a specific area.\n\n\nNext, we will append the `lag_sum` GDPPC field into `hunan` sf data frame by using the code block below.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhunan <- left_join(hunan, lag.res)\n```\n:::\n\n\n\nNow, we can plot  the GDPPC, Spatial Lag GDPPC, Spatial Lag Sum GDPPC for comparison using the code block below.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngdppc <- qtm(hunan, \"GDPPC\")\nlag_gdppc <- qtm(hunan, \"lag GDPPC\")\nlag_sum_gdppc <- qtm(hunan, \"lag_sum GDPPC\")\ntmap_arrange(gdppc, lag_gdppc, lag_sum_gdppc, asp=1, ncol=3)\n```\n\n::: {.cell-output-display}\n![](Hands-on_Ex04a_files/figure-html/unnamed-chunk-49-1.png){width=672}\n:::\n:::\n\n\n\n### Spatial Window Average\n\nThe spatial window average uses row-standardized weights and includes the diagonal element. To do this in R, we need to go back to the neighbors structure and add the diagonal element before assigning weights.\n\nTo add the diagonal element to the neighbour list, we just need to use *include.self()* from **spdep**.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nwm_qs <- include.self(wm_q)\n```\n:::\n\n\n\n\nLet us take a good look at the neighbour list of area 85 by using the code block below.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nwm_qs[[85]]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1]  1  2  3  5  6 32 56 57 69 75 78 85\n```\n\n\n:::\n:::\n\n\n\nNotice that now region 85 has 12 neighbours instead of 11.\n\nNow we obtain weights with `nb2listw()`.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nwm_qs <- nb2listw(wm_qs)\nwm_qs\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nCharacteristics of weights list object:\nNeighbour list object:\nNumber of regions: 88 \nNumber of nonzero links: 536 \nPercentage nonzero weights: 6.921488 \nAverage number of links: 6.090909 \n\nWeights style: W \nWeights constants summary:\n   n   nn S0       S1       S2\nW 88 7744 88 30.90265 357.5308\n```\n\n\n:::\n:::\n\n\nAgain, we use *nb2listw()* and *glist()* to explicitly assign weight values.\n\nLastly, we just need to create the lag variable from our weight structure and GDPPC variable.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlag_w_avg_gpdpc <- lag.listw(wm_qs, \n                             hunan$GDPPC)\nlag_w_avg_gpdpc\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1] 24650.50 22434.17 26233.00 27084.60 26927.00 22230.17 47621.20 37160.12\n [9] 49224.71 29886.89 26627.50 22690.17 25366.40 25825.75 30329.00 32682.83\n[17] 25948.62 23987.67 25463.14 21904.38 23127.50 25949.83 20018.75 19524.17\n[25] 18955.00 17800.40 15883.00 18831.33 14832.50 17965.00 17159.89 16199.44\n[33] 18764.50 26878.75 23188.86 20788.14 12365.20 15985.00 13764.83 11907.43\n[41] 17128.14 14593.62 11644.29 12706.00 21712.29 43548.25 35049.00 16226.83\n[49] 19294.40 18156.00 19954.75 18145.17 12132.75 18419.29 14050.83 23619.75\n[57] 24552.71 24733.67 16762.60 20932.60 19467.75 18334.00 22541.00 26028.00\n[65] 29128.50 46569.00 47576.60 36545.50 20838.50 22531.00 42115.50 27619.00\n[73] 27611.33 44523.29 18127.43 28746.38 20734.50 33880.62 14716.38 28516.22\n[81] 18086.14 21244.50 29568.80 48119.71 22310.75 43151.60 17133.40 17009.33\n```\n\n\n:::\n:::\n\n\nNext, we will convert the lag variable listw object into a data.frame by using `as.data.frame()`.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlag.list.wm_qs <- list(hunan$NAME_3, lag.listw(wm_qs, hunan$GDPPC))\nlag_wm_qs.res <- as.data.frame(lag.list.wm_qs)\ncolnames(lag_wm_qs.res) <- c(\"NAME_3\", \"lag_window_avg GDPPC\")\n```\n:::\n\n\n\n::: callout-note\nThe third command line on the code chunk above renames the field names of *lag_wm_q1.res* object into *NAME_3* and *lag_window_avg GDPPC* respectively.\n:::\n\nNext, the code chunk below will be used to append *lag_window_avg GDPPC* values onto *hunan* sf data.frame by using *left_join()* of **dplyr** package.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhunan <- left_join(hunan, lag_wm_qs.res)\n```\n:::\n\n\n\nTo compare the values of lag GDPPC and Spatial window average, `kable()` of Knitr package is used to prepare a table using the code chunk below.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhunan %>%\n  select(\"County\", \n         \"lag GDPPC\", \n         \"lag_window_avg GDPPC\") %>%\n  kable()\n```\n\n::: {.cell-output-display}\n\n\n|County        | lag GDPPC| lag_window_avg GDPPC|geometry                       |\n|:-------------|---------:|--------------------:|:------------------------------|\n|Anxiang       |  24847.20|             24650.50|POLYGON ((112.0625 29.75523... |\n|Hanshou       |  22724.80|             22434.17|POLYGON ((112.2288 29.11684... |\n|Jinshi        |  24143.25|             26233.00|POLYGON ((111.8927 29.6013,... |\n|Li            |  27737.50|             27084.60|POLYGON ((111.3731 29.94649... |\n|Linli         |  27270.25|             26927.00|POLYGON ((111.6324 29.76288... |\n|Shimen        |  21248.80|             22230.17|POLYGON ((110.8825 30.11675... |\n|Liuyang       |  43747.00|             47621.20|POLYGON ((113.9905 28.5682,... |\n|Ningxiang     |  33582.71|             37160.12|POLYGON ((112.7181 28.38299... |\n|Wangcheng     |  45651.17|             49224.71|POLYGON ((112.7914 28.52688... |\n|Anren         |  32027.62|             29886.89|POLYGON ((113.1757 26.82734... |\n|Guidong       |  32671.00|             26627.50|POLYGON ((114.1799 26.20117... |\n|Jiahe         |  20810.00|             22690.17|POLYGON ((112.4425 25.74358... |\n|Linwu         |  25711.50|             25366.40|POLYGON ((112.5914 25.55143... |\n|Rucheng       |  30672.33|             25825.75|POLYGON ((113.6759 25.87578... |\n|Yizhang       |  33457.75|             30329.00|POLYGON ((113.2621 25.68394... |\n|Yongxing      |  31689.20|             32682.83|POLYGON ((113.3169 26.41843... |\n|Zixing        |  20269.00|             25948.62|POLYGON ((113.7311 26.16259... |\n|Changning     |  23901.60|             23987.67|POLYGON ((112.6144 26.60198... |\n|Hengdong      |  25126.17|             25463.14|POLYGON ((113.1056 27.21007... |\n|Hengnan       |  21903.43|             21904.38|POLYGON ((112.7599 26.98149... |\n|Hengshan      |  22718.60|             23127.50|POLYGON ((112.607 27.4689, ... |\n|Leiyang       |  25918.80|             25949.83|POLYGON ((112.9996 26.69276... |\n|Qidong        |  20307.00|             20018.75|POLYGON ((111.7818 27.0383,... |\n|Chenxi        |  20023.80|             19524.17|POLYGON ((110.2624 28.21778... |\n|Zhongfang     |  16576.80|             18955.00|POLYGON ((109.9431 27.72858... |\n|Huitong       |  18667.00|             17800.40|POLYGON ((109.9419 27.10512... |\n|Jingzhou      |  14394.67|             15883.00|POLYGON ((109.8186 26.75842... |\n|Mayang        |  19848.80|             18831.33|POLYGON ((109.795 27.98008,... |\n|Tongdao       |  15516.33|             14832.50|POLYGON ((109.9294 26.46561... |\n|Xinhuang      |  20518.00|             17965.00|POLYGON ((109.227 27.43733,... |\n|Xupu          |  17572.00|             17159.89|POLYGON ((110.7189 28.30485... |\n|Yuanling      |  15200.12|             16199.44|POLYGON ((110.9652 28.99895... |\n|Zhijiang      |  18413.80|             18764.50|POLYGON ((109.8818 27.60661... |\n|Lengshuijiang |  14419.33|             26878.75|POLYGON ((111.5307 27.81472... |\n|Shuangfeng    |  24094.50|             23188.86|POLYGON ((112.263 27.70421,... |\n|Xinhua        |  22019.83|             20788.14|POLYGON ((111.3345 28.19642... |\n|Chengbu       |  12923.50|             12365.20|POLYGON ((110.4455 26.69317... |\n|Dongan        |  14756.00|             15985.00|POLYGON ((111.4531 26.86812... |\n|Dongkou       |  13869.80|             13764.83|POLYGON ((110.6622 27.37305... |\n|Longhui       |  12296.67|             11907.43|POLYGON ((110.985 27.65983,... |\n|Shaodong      |  15775.17|             17128.14|POLYGON ((111.9054 27.40254... |\n|Suining       |  14382.86|             14593.62|POLYGON ((110.389 27.10006,... |\n|Wugang        |  11566.33|             11644.29|POLYGON ((110.9878 27.03345... |\n|Xinning       |  13199.50|             12706.00|POLYGON ((111.0736 26.84627... |\n|Xinshao       |  23412.00|             21712.29|POLYGON ((111.6013 27.58275... |\n|Shaoshan      |  39541.00|             43548.25|POLYGON ((112.5391 27.97742... |\n|Xiangxiang    |  36186.60|             35049.00|POLYGON ((112.4549 28.05783... |\n|Baojing       |  16559.60|             16226.83|POLYGON ((109.7015 28.82844... |\n|Fenghuang     |  20772.50|             19294.40|POLYGON ((109.5239 28.19206... |\n|Guzhang       |  19471.20|             18156.00|POLYGON ((109.8968 28.74034... |\n|Huayuan       |  19827.33|             19954.75|POLYGON ((109.5647 28.61712... |\n|Jishou        |  15466.80|             18145.17|POLYGON ((109.8375 28.4696,... |\n|Longshan      |  12925.67|             12132.75|POLYGON ((109.6337 29.62521... |\n|Luxi          |  18577.17|             18419.29|POLYGON ((110.1067 28.41835... |\n|Yongshun      |  14943.00|             14050.83|POLYGON ((110.0003 29.29499... |\n|Anhua         |  24913.00|             23619.75|POLYGON ((111.6034 28.63716... |\n|Nan           |  25093.00|             24552.71|POLYGON ((112.3232 29.46074... |\n|Yuanjiang     |  24428.80|             24733.67|POLYGON ((112.4391 29.1791,... |\n|Jianghua      |  17003.00|             16762.60|POLYGON ((111.6461 25.29661... |\n|Lanshan       |  21143.75|             20932.60|POLYGON ((112.2286 25.61123... |\n|Ningyuan      |  20435.00|             19467.75|POLYGON ((112.0715 26.09892... |\n|Shuangpai     |  17131.33|             18334.00|POLYGON ((111.8864 26.11957... |\n|Xintian       |  24569.75|             22541.00|POLYGON ((112.2578 26.0796,... |\n|Huarong       |  23835.50|             26028.00|POLYGON ((112.9242 29.69134... |\n|Linxiang      |  26360.00|             29128.50|POLYGON ((113.5502 29.67418... |\n|Miluo         |  47383.40|             46569.00|POLYGON ((112.9902 29.02139... |\n|Pingjiang     |  55157.75|             47576.60|POLYGON ((113.8436 29.06152... |\n|Xiangyin      |  37058.00|             36545.50|POLYGON ((112.9173 28.98264... |\n|Cili          |  21546.67|             20838.50|POLYGON ((110.8822 29.69017... |\n|Chaling       |  23348.67|             22531.00|POLYGON ((113.7666 27.10573... |\n|Liling        |  42323.67|             42115.50|POLYGON ((113.5673 27.94346... |\n|Yanling       |  28938.60|             27619.00|POLYGON ((113.9292 26.6154,... |\n|You           |  25880.80|             27611.33|POLYGON ((113.5879 27.41324... |\n|Zhuzhou       |  47345.67|             44523.29|POLYGON ((113.2493 28.02411... |\n|Sangzhi       |  18711.33|             18127.43|POLYGON ((110.556 29.40543,... |\n|Yueyang       |  29087.29|             28746.38|POLYGON ((113.343 29.61064,... |\n|Qiyang        |  20748.29|             20734.50|POLYGON ((111.5563 26.81318... |\n|Taojiang      |  35933.71|             33880.62|POLYGON ((112.0508 28.67265... |\n|Shaoyang      |  15439.71|             14716.38|POLYGON ((111.5013 27.30207... |\n|Lianyuan      |  29787.50|             28516.22|POLYGON ((111.6789 28.02946... |\n|Hongjiang     |  18145.00|             18086.14|POLYGON ((110.1441 27.47513... |\n|Hengyang      |  21617.00|             21244.50|POLYGON ((112.7144 26.98613... |\n|Guiyang       |  29203.89|             29568.80|POLYGON ((113.0811 26.04963... |\n|Changsha      |  41363.67|             48119.71|POLYGON ((112.9421 28.03722... |\n|Taoyuan       |  22259.09|             22310.75|POLYGON ((112.0612 29.32855... |\n|Xiangtan      |  44939.56|             43151.60|POLYGON ((113.0426 27.8942,... |\n|Dao           |  16902.00|             17133.40|POLYGON ((111.498 25.81679,... |\n|Jiangyong     |  16930.00|             17009.33|POLYGON ((111.3659 25.39472... |\n\n\n:::\n:::\n\n\n\n\nLastly, `qtm()` of **tmap** package is used to plot the **lag_gdppc** and **w_ave_gdppc** maps next to each other for quick comparison.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nw_avg_gdppc <- qtm(hunan, \"lag_window_avg GDPPC\")\ntmap_arrange(lag_gdppc, w_avg_gdppc, asp=1, ncol=2)\n```\n\n::: {.cell-output-display}\n![](Hands-on_Ex04a_files/figure-html/unnamed-chunk-57-1.png){width=1152}\n:::\n:::\n\n\n\n::: callout-tip\nFor more effective comparison, it is advisable to use the core tmap mapping functions.\n:::\n\n### Spatial Window Sum\n\n> The spatial window sum is the counter part of the window average, but without using row-standardized weights.\n\nTo add the diagonal element to the neighbour list, we just need to use *include.self()* from **spdep**.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nwm_qs <- include.self(wm_q)\nwm_qs\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nNeighbour list object:\nNumber of regions: 88 \nNumber of nonzero links: 536 \nPercentage nonzero weights: 6.921488 \nAverage number of links: 6.090909 \n```\n\n\n:::\n:::\n\n\n\nNext, we will assign binary weights to the neighbour structure that includes the diagonal element.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nb_weights <- lapply(wm_qs, function(x) 0*x + 1)\nb_weights[1]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[[1]]\n[1] 1 1 1 1 1 1\n```\n\n\n:::\n:::\n\n\n\nNotice that now region 85 has 12 neighbours instead of 11.\n\nAgain, we use `nb2listw()` and `glist()` to explicitly assign weight values.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nb_weights2 <- nb2listw(wm_qs, \n                       glist = b_weights, \n                       style = \"B\")\nb_weights2\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nCharacteristics of weights list object:\nNeighbour list object:\nNumber of regions: 88 \nNumber of nonzero links: 536 \nPercentage nonzero weights: 6.921488 \nAverage number of links: 6.090909 \n\nWeights style: B \nWeights constants summary:\n   n   nn  S0   S1    S2\nB 88 7744 536 1072 14160\n```\n\n\n:::\n:::\n\n\n\nWith our new weight structure, we can compute the lag variable with `lag.listw()`.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nw_sum_gdppc <- list(hunan$NAME_3, lag.listw(b_weights2, hunan$GDPPC))\nw_sum_gdppc\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[[1]]\n [1] \"Anxiang\"       \"Hanshou\"       \"Jinshi\"        \"Li\"           \n [5] \"Linli\"         \"Shimen\"        \"Liuyang\"       \"Ningxiang\"    \n [9] \"Wangcheng\"     \"Anren\"         \"Guidong\"       \"Jiahe\"        \n[13] \"Linwu\"         \"Rucheng\"       \"Yizhang\"       \"Yongxing\"     \n[17] \"Zixing\"        \"Changning\"     \"Hengdong\"      \"Hengnan\"      \n[21] \"Hengshan\"      \"Leiyang\"       \"Qidong\"        \"Chenxi\"       \n[25] \"Zhongfang\"     \"Huitong\"       \"Jingzhou\"      \"Mayang\"       \n[29] \"Tongdao\"       \"Xinhuang\"      \"Xupu\"          \"Yuanling\"     \n[33] \"Zhijiang\"      \"Lengshuijiang\" \"Shuangfeng\"    \"Xinhua\"       \n[37] \"Chengbu\"       \"Dongan\"        \"Dongkou\"       \"Longhui\"      \n[41] \"Shaodong\"      \"Suining\"       \"Wugang\"        \"Xinning\"      \n[45] \"Xinshao\"       \"Shaoshan\"      \"Xiangxiang\"    \"Baojing\"      \n[49] \"Fenghuang\"     \"Guzhang\"       \"Huayuan\"       \"Jishou\"       \n[53] \"Longshan\"      \"Luxi\"          \"Yongshun\"      \"Anhua\"        \n[57] \"Nan\"           \"Yuanjiang\"     \"Jianghua\"      \"Lanshan\"      \n[61] \"Ningyuan\"      \"Shuangpai\"     \"Xintian\"       \"Huarong\"      \n[65] \"Linxiang\"      \"Miluo\"         \"Pingjiang\"     \"Xiangyin\"     \n[69] \"Cili\"          \"Chaling\"       \"Liling\"        \"Yanling\"      \n[73] \"You\"           \"Zhuzhou\"       \"Sangzhi\"       \"Yueyang\"      \n[77] \"Qiyang\"        \"Taojiang\"      \"Shaoyang\"      \"Lianyuan\"     \n[81] \"Hongjiang\"     \"Hengyang\"      \"Guiyang\"       \"Changsha\"     \n[85] \"Taoyuan\"       \"Xiangtan\"      \"Dao\"           \"Jiangyong\"    \n\n[[2]]\n [1] 147903 134605 131165 135423 134635 133381 238106 297281 344573 268982\n[11] 106510 136141 126832 103303 151645 196097 207589 143926 178242 175235\n[21] 138765 155699 160150 117145 113730  89002  63532 112988  59330  35930\n[31] 154439 145795 112587 107515 162322 145517  61826  79925  82589  83352\n[41] 119897 116749  81510  63530 151986 174193 210294  97361  96472 108936\n[51]  79819 108871  48531 128935  84305 188958 171869 148402  83813 104663\n[61] 155742  73336 112705  78084  58257 279414 237883 219273  83354  90124\n[71] 168462 165714 165668 311663 126892 229971 165876 271045 117731 256646\n[81] 126603 127467 295688 336838 267729 431516  85667  51028\n```\n\n\n:::\n:::\n\n\n\nNext, we will convert the lag variable listw object into a data.frame by using `as.data.frame()`.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nw_sum_gdppc.res <- as.data.frame(w_sum_gdppc)\ncolnames(w_sum_gdppc.res) <- c(\"NAME_3\", \"w_sum GDPPC\")\n```\n:::\n\n\n\nNote: The second command line on the code chunk above renames the field names of *w_sum_gdppc.res* object into *NAME_3* and *w_sum GDPPC* respectively.\n\nNext, the code chunk below will be used to append *w_sum GDPPC* values onto *hunan* sf data.frame by using *left_join()* of **dplyr** package.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhunan <- left_join(hunan, w_sum_gdppc.res)\n```\n:::\n\n\n\nTo compare the values of lag GDPPC and Spatial window average, `kable()` of Knitr package is used to prepare a table using the code chunk below.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhunan %>%\n  select(\"County\", \"lag_sum GDPPC\", \"w_sum GDPPC\") %>%\n  kable()\n```\n\n::: {.cell-output-display}\n\n\n|County        | lag_sum GDPPC| w_sum GDPPC|geometry                       |\n|:-------------|-------------:|-----------:|:------------------------------|\n|Anxiang       |        124236|      147903|POLYGON ((112.0625 29.75523... |\n|Hanshou       |        113624|      134605|POLYGON ((112.2288 29.11684... |\n|Jinshi        |         96573|      131165|POLYGON ((111.8927 29.6013,... |\n|Li            |        110950|      135423|POLYGON ((111.3731 29.94649... |\n|Linli         |        109081|      134635|POLYGON ((111.6324 29.76288... |\n|Shimen        |        106244|      133381|POLYGON ((110.8825 30.11675... |\n|Liuyang       |        174988|      238106|POLYGON ((113.9905 28.5682,... |\n|Ningxiang     |        235079|      297281|POLYGON ((112.7181 28.38299... |\n|Wangcheng     |        273907|      344573|POLYGON ((112.7914 28.52688... |\n|Anren         |        256221|      268982|POLYGON ((113.1757 26.82734... |\n|Guidong       |         98013|      106510|POLYGON ((114.1799 26.20117... |\n|Jiahe         |        104050|      136141|POLYGON ((112.4425 25.74358... |\n|Linwu         |        102846|      126832|POLYGON ((112.5914 25.55143... |\n|Rucheng       |         92017|      103303|POLYGON ((113.6759 25.87578... |\n|Yizhang       |        133831|      151645|POLYGON ((113.2621 25.68394... |\n|Yongxing      |        158446|      196097|POLYGON ((113.3169 26.41843... |\n|Zixing        |        141883|      207589|POLYGON ((113.7311 26.16259... |\n|Changning     |        119508|      143926|POLYGON ((112.6144 26.60198... |\n|Hengdong      |        150757|      178242|POLYGON ((113.1056 27.21007... |\n|Hengnan       |        153324|      175235|POLYGON ((112.7599 26.98149... |\n|Hengshan      |        113593|      138765|POLYGON ((112.607 27.4689, ... |\n|Leiyang       |        129594|      155699|POLYGON ((112.9996 26.69276... |\n|Qidong        |        142149|      160150|POLYGON ((111.7818 27.0383,... |\n|Chenxi        |        100119|      117145|POLYGON ((110.2624 28.21778... |\n|Zhongfang     |         82884|      113730|POLYGON ((109.9431 27.72858... |\n|Huitong       |         74668|       89002|POLYGON ((109.9419 27.10512... |\n|Jingzhou      |         43184|       63532|POLYGON ((109.8186 26.75842... |\n|Mayang        |         99244|      112988|POLYGON ((109.795 27.98008,... |\n|Tongdao       |         46549|       59330|POLYGON ((109.9294 26.46561... |\n|Xinhuang      |         20518|       35930|POLYGON ((109.227 27.43733,... |\n|Xupu          |        140576|      154439|POLYGON ((110.7189 28.30485... |\n|Yuanling      |        121601|      145795|POLYGON ((110.9652 28.99895... |\n|Zhijiang      |         92069|      112587|POLYGON ((109.8818 27.60661... |\n|Lengshuijiang |         43258|      107515|POLYGON ((111.5307 27.81472... |\n|Shuangfeng    |        144567|      162322|POLYGON ((112.263 27.70421,... |\n|Xinhua        |        132119|      145517|POLYGON ((111.3345 28.19642... |\n|Chengbu       |         51694|       61826|POLYGON ((110.4455 26.69317... |\n|Dongan        |         59024|       79925|POLYGON ((111.4531 26.86812... |\n|Dongkou       |         69349|       82589|POLYGON ((110.6622 27.37305... |\n|Longhui       |         73780|       83352|POLYGON ((110.985 27.65983,... |\n|Shaodong      |         94651|      119897|POLYGON ((111.9054 27.40254... |\n|Suining       |        100680|      116749|POLYGON ((110.389 27.10006,... |\n|Wugang        |         69398|       81510|POLYGON ((110.9878 27.03345... |\n|Xinning       |         52798|       63530|POLYGON ((111.0736 26.84627... |\n|Xinshao       |        140472|      151986|POLYGON ((111.6013 27.58275... |\n|Shaoshan      |        118623|      174193|POLYGON ((112.5391 27.97742... |\n|Xiangxiang    |        180933|      210294|POLYGON ((112.4549 28.05783... |\n|Baojing       |         82798|       97361|POLYGON ((109.7015 28.82844... |\n|Fenghuang     |         83090|       96472|POLYGON ((109.5239 28.19206... |\n|Guzhang       |         97356|      108936|POLYGON ((109.8968 28.74034... |\n|Huayuan       |         59482|       79819|POLYGON ((109.5647 28.61712... |\n|Jishou        |         77334|      108871|POLYGON ((109.8375 28.4696,... |\n|Longshan      |         38777|       48531|POLYGON ((109.6337 29.62521... |\n|Luxi          |        111463|      128935|POLYGON ((110.1067 28.41835... |\n|Yongshun      |         74715|       84305|POLYGON ((110.0003 29.29499... |\n|Anhua         |        174391|      188958|POLYGON ((111.6034 28.63716... |\n|Nan           |        150558|      171869|POLYGON ((112.3232 29.46074... |\n|Yuanjiang     |        122144|      148402|POLYGON ((112.4391 29.1791,... |\n|Jianghua      |         68012|       83813|POLYGON ((111.6461 25.29661... |\n|Lanshan       |         84575|      104663|POLYGON ((112.2286 25.61123... |\n|Ningyuan      |        143045|      155742|POLYGON ((112.0715 26.09892... |\n|Shuangpai     |         51394|       73336|POLYGON ((111.8864 26.11957... |\n|Xintian       |         98279|      112705|POLYGON ((112.2578 26.0796,... |\n|Huarong       |         47671|       78084|POLYGON ((112.9242 29.69134... |\n|Linxiang      |         26360|       58257|POLYGON ((113.5502 29.67418... |\n|Miluo         |        236917|      279414|POLYGON ((112.9902 29.02139... |\n|Pingjiang     |        220631|      237883|POLYGON ((113.8436 29.06152... |\n|Xiangyin      |        185290|      219273|POLYGON ((112.9173 28.98264... |\n|Cili          |         64640|       83354|POLYGON ((110.8822 29.69017... |\n|Chaling       |         70046|       90124|POLYGON ((113.7666 27.10573... |\n|Liling        |        126971|      168462|POLYGON ((113.5673 27.94346... |\n|Yanling       |        144693|      165714|POLYGON ((113.9292 26.6154,... |\n|You           |        129404|      165668|POLYGON ((113.5879 27.41324... |\n|Zhuzhou       |        284074|      311663|POLYGON ((113.2493 28.02411... |\n|Sangzhi       |        112268|      126892|POLYGON ((110.556 29.40543,... |\n|Yueyang       |        203611|      229971|POLYGON ((113.343 29.61064,... |\n|Qiyang        |        145238|      165876|POLYGON ((111.5563 26.81318... |\n|Taojiang      |        251536|      271045|POLYGON ((112.0508 28.67265... |\n|Shaoyang      |        108078|      117731|POLYGON ((111.5013 27.30207... |\n|Lianyuan      |        238300|      256646|POLYGON ((111.6789 28.02946... |\n|Hongjiang     |        108870|      126603|POLYGON ((110.1441 27.47513... |\n|Hengyang      |        108085|      127467|POLYGON ((112.7144 26.98613... |\n|Guiyang       |        262835|      295688|POLYGON ((113.0811 26.04963... |\n|Changsha      |        248182|      336838|POLYGON ((112.9421 28.03722... |\n|Taoyuan       |        244850|      267729|POLYGON ((112.0612 29.32855... |\n|Xiangtan      |        404456|      431516|POLYGON ((113.0426 27.8942,... |\n|Dao           |         67608|       85667|POLYGON ((111.498 25.81679,... |\n|Jiangyong     |         33860|       51028|POLYGON ((111.3659 25.39472... |\n\n\n:::\n:::\n\n\n\nLastly, `qtm()` of **tmap** package is used to plot the lag_sum GDPPC and w_sum_gdppc maps next to each other for quick comparison.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nw_sum_gdppc <- qtm(hunan, \"w_sum GDPPC\")\ntmap_arrange(lag_sum_gdppc, w_sum_gdppc, asp=1, ncol=2)\n```\n\n::: {.cell-output-display}\n![](Hands-on_Ex04a_files/figure-html/unnamed-chunk-65-1.png){width=1152}\n:::\n:::\n",
    "supporting": [
      "Hands-on_Ex04a_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}