{
  "hash": "9c5a7cd0c341c2a9afcc020375b728d1",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"9A: Modelling Geographical Accessibility\"\nsubtitle: \"In this exercise, we will learn to model geographical accessibility using Hansen's potential model, Spatial Accessibility Measure (SAM), and other methods in R.\"\n# draft: true\ndate: \"Sep 30, 2024\"\ndate-modified: \"last-modified\"\nauthor: Teng Kok Wai (Walter)\nexecute:\n  echo: true\n  eval: true\n  freeze: true\n  message: false\n  warning: false\nformat:\n  html:\n    code-link: true\n    toc: true\nnumber-sections: true\nnumber-offset: 1\neditor: visual\n---\n\n\n\n## Exercise 09A Reference\n\n[R for Geospatial Data Science and Analytics - 17  Modelling Geographical Accessibility](https://r4gdsa.netlify.app/chap17.html)\n\n## Overview\n\nIn this exercise, we will learn to model geographical accessibility using Hansen's potential model, Spatial Accessibility Measure (SAM), and other methods in R.\n\n## Learning Outcome\n\n-   Import GIS polygon data into R and save them as a simple feature data frame using the **sf** package.\n-   Import aspatial data into R and save them as a simple feature data frame using the **sf** package.\n-   Compute accessibility measures using Hansen's potential model and Spatial Accessibility Measure (SAM).\n-   Visualize the accessibility measures using **tmap** and **ggplot2** packages.\n\n## The Data\n\nThe following datasets will be used in this exercise:\n\n| **Data Set** | **Description** | **Format** |\n|----------------|-----------------------------------------|----------------|\n| `MP14_SUBZONE_NO_SEA_PL` | URA Master Plan 2014 subzone boundary GIS data. | ESRI Shapefile |\n| `hexagons` | A 250m radius hexagons GIS data created using the `st_make_grid()` function of the **sf** package. | ESRI Shapefile |\n| `ELDERCARE` | GIS data showing the location of eldercare services, available in both ESRI shapefile and Google KML format. | ESRI Shapefile |\n| `OD_Matrix` | A distance matrix with origin-destination information, including entry, network, and exit costs. | CSV |\n\n> All the values of the cost related fields are in **metres**.\n\n## Installing and Launching the R Packages\n\nThe following R packages will be used in this exercise:\n\n| **Package** | **Purpose** | **Use Case in Exercise** |\n|-----------------|---------------------------|----------------------------|\n| **sf** | Handles spatial data; imports, manages, and processes vector-based geospatial data. | Importing and transforming geospatial datasets such as subzone boundaries, hexagons, and eldercare locations. |\n| **SpatialAcc** | Provides functions for computing geographical accessibility measures. | Calculating Hansen's potential model, Spatial Accessibility Measure (SAM), and other accessibility metrics. |\n| **tidyverse** | A collection of R packages for data science tasks like data manipulation, visualization, and modeling. | Wrangling and visualizing data, including importing CSV files and performing data transformations. |\n| **tmap** | Creates static and interactive thematic maps using cartographic quality elements. | Visualizing accessibility measures on thematic maps. |\n| **ggplot2** | Creates data visualizations using a layered grammar of graphics. | Visualizing statistical graphics such as histograms and boxplots of accessibility measures. |\n| **ggstatsplot** | Enhances plots with statistical details and facilitates data visualization. | Creating statistically enriched plots for exploratory data analysis and comparing distributions. |\n| **reshape2** | Provides tools to reshape data between wide and long formats. | Transforming data matrices into suitable formats for modeling. |\n\nTo install and load these packages, use the following code:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\npacman::p_load(tmap, SpatialAcc, sf, ggstatsplot, reshape2, tidyverse)\n```\n:::\n\n\n\n## Geospatial Data Wrangling\n\n### Importing Geospatial Data\n\nThree geospatial datasets—*MP14_SUBZONE_NO_SEA_PL*, *hexagons*, and *ELDERCARE*—are imported from the *data/geospatial* folder using the `st_read()` function from the **sf** package.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmpsz <- st_read(dsn = \"data/geospatial\", layer = \"MP14_SUBZONE_NO_SEA_PL\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nReading layer `MP14_SUBZONE_NO_SEA_PL' from data source \n  `/Users/walter/code/isss626/isss626-gaa/Hands-on_Ex/Hands-on_Ex09/data/geospatial' \n  using driver `ESRI Shapefile'\nSimple feature collection with 323 features and 15 fields\nGeometry type: MULTIPOLYGON\nDimension:     XY\nBounding box:  xmin: 2667.538 ymin: 15748.72 xmax: 56396.44 ymax: 50256.33\nProjected CRS: SVY21\n```\n\n\n:::\n\n```{.r .cell-code}\nhexagons <- st_read(dsn = \"data/geospatial\", layer = \"hexagons\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nReading layer `hexagons' from data source \n  `/Users/walter/code/isss626/isss626-gaa/Hands-on_Ex/Hands-on_Ex09/data/geospatial' \n  using driver `ESRI Shapefile'\nSimple feature collection with 3125 features and 6 fields\nGeometry type: POLYGON\nDimension:     XY\nBounding box:  xmin: 2667.538 ymin: 21506.33 xmax: 50010.26 ymax: 50256.33\nProjected CRS: SVY21 / Singapore TM\n```\n\n\n:::\n\n```{.r .cell-code}\neldercare <- st_read(dsn = \"data/geospatial\", layer = \"ELDERCARE\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nReading layer `ELDERCARE' from data source \n  `/Users/walter/code/isss626/isss626-gaa/Hands-on_Ex/Hands-on_Ex09/data/geospatial' \n  using driver `ESRI Shapefile'\nSimple feature collection with 120 features and 19 fields\nGeometry type: POINT\nDimension:     XY\nBounding box:  xmin: 14481.92 ymin: 28218.43 xmax: 41665.14 ymax: 46804.9\nProjected CRS: SVY21 / Singapore TM\n```\n\n\n:::\n:::\n\n\n\n### Updating CRS Information\n\nWe update the Coordinate Reference System (CRS) to EPSG:3414 for all datasets.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmpsz <- st_transform(mpsz, 3414)\neldercare <- st_transform(eldercare, 3414)\nhexagons <- st_transform(hexagons, 3414)\n```\n:::\n\n\n\nYou can verify the CRS of *mpsz* using `st_crs()`:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nst_crs(mpsz)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nCoordinate Reference System:\n  User input: EPSG:3414 \n  wkt:\nPROJCRS[\"SVY21 / Singapore TM\",\n    BASEGEOGCRS[\"SVY21\",\n        DATUM[\"SVY21\",\n            ELLIPSOID[\"WGS 84\",6378137,298.257223563,\n                LENGTHUNIT[\"metre\",1]]],\n        PRIMEM[\"Greenwich\",0,\n            ANGLEUNIT[\"degree\",0.0174532925199433]],\n        ID[\"EPSG\",4757]],\n    CONVERSION[\"Singapore Transverse Mercator\",\n        METHOD[\"Transverse Mercator\",\n            ID[\"EPSG\",9807]],\n        PARAMETER[\"Latitude of natural origin\",1.36666666666667,\n            ANGLEUNIT[\"degree\",0.0174532925199433],\n            ID[\"EPSG\",8801]],\n        PARAMETER[\"Longitude of natural origin\",103.833333333333,\n            ANGLEUNIT[\"degree\",0.0174532925199433],\n            ID[\"EPSG\",8802]],\n        PARAMETER[\"Scale factor at natural origin\",1,\n            SCALEUNIT[\"unity\",1],\n            ID[\"EPSG\",8805]],\n        PARAMETER[\"False easting\",28001.642,\n            LENGTHUNIT[\"metre\",1],\n            ID[\"EPSG\",8806]],\n        PARAMETER[\"False northing\",38744.572,\n            LENGTHUNIT[\"metre\",1],\n            ID[\"EPSG\",8807]]],\n    CS[Cartesian,2],\n        AXIS[\"northing (N)\",north,\n            ORDER[1],\n            LENGTHUNIT[\"metre\",1]],\n        AXIS[\"easting (E)\",east,\n            ORDER[2],\n            LENGTHUNIT[\"metre\",1]],\n    USAGE[\n        SCOPE[\"Cadastre, engineering survey, topographic mapping.\"],\n        AREA[\"Singapore - onshore and offshore.\"],\n        BBOX[1.13,103.59,1.47,104.07]],\n    ID[\"EPSG\",3414]]\n```\n\n\n:::\n:::\n\n\n\n### Cleaning and Updating Attribute Fields\n\nWe remove redundant fields and add new ones. For *eldercare*, we add a `capacity` field, and for *hexagons*, we add a `demand` field, both with a constant value of 100.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\neldercare <- eldercare %>%\n  select(fid, ADDRESSPOS) %>%\n  mutate(capacity = 100)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nhexagons <- hexagons %>%\n  select(fid) %>%\n  mutate(demand = 100)\n```\n:::\n\n\n\n::: callout-tip\nFor this exercise, a constant value of 100 is used. In practice, actual demand and capacity values should be used.\n:::\n\n## Aspatial Data Handling and Wrangling\n\n### Importing Distance Matrix\n\nWe import the `OD_Matrix.csv` file using `read_csv()` from the **readr** package, which creates a tibble data frame called `ODMatrix`.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nODMatrix <- read_csv(\"data/aspatial/OD_Matrix.csv\", skip = 0)\n```\n:::\n\n\n\n### Tidying the Distance Matrix\n\nThe imported *ODMatrix* organizes the distance matrix column-wise.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhead(ODMatrix)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 6 × 6\n  origin_id destination_id entry_cost network_cost exit_cost total_cost\n      <dbl>          <dbl>      <dbl>        <dbl>     <dbl>      <dbl>\n1         1              1       668.       19847.      47.6     20562.\n2         1              2       668.       45027.      31.9     45727.\n3         1              3       668.       17644.     173.      18486.\n4         1              4       668.       36010.      92.2     36770.\n5         1              5       668.       31068.      64.6     31801.\n6         1              6       668.       31195.     117.      31980.\n```\n\n\n:::\n:::\n\n\n\nHowever, most R modeling packages expect the matrix in a format where rows represent origins (from) and columns represent destinations (to).\n\nWe use `pivot_wider()` from the **tidyr** package to reshape the data from a long format to a wide format.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndistmat <- ODMatrix %>%\n  select(origin_id, destination_id, total_cost) %>%\n  pivot_wider(names_from = destination_id, values_from = total_cost) %>%\n  select(-origin_id)\n```\n:::\n\n\n\n### Converting Distance to Kilometers\n\nSince the distances are in meters (due to the SVY21 projected coordinate system), we convert them to kilometers using the code below.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndistmat_km <- as.matrix(distmat/1000)\n```\n:::\n\n\n\n## Modelling and Visualising Accessibility using Hansen Method\n\n::: callout-note\nHansen Accessibility Model (1959) is based upon concept that the more accessible an area is to various activities and the more vacant land area has greater growth potential. It is a spatial analysis method used to measure accessibility by considering both the distance to and the capacity of services or facilities (e.g., eldercare centers). It calculates accessibility as a function of the proximity of a location to these facilities, weighted by their capacity, and decays with distance.\n\nFor more info: [Hansen Accessibility Model - Front Desk Architects](https://frontdesk.co.in/planning/land-use-and-transport-planning/hansen-accessibility-model/)\n:::\n\n### Computing Hansen's Accessibility\n\nWe compute Hansen's accessibility using the `ac()` function from the **SpatialAcc** package. The code below calculates accessibility, and the output is saved in a data frame called `acc_Hansen`.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nacc_Hansen <- data.frame(ac(hexagons$demand,\n                            eldercare$capacity,\n                            distmat_km, \n                            power = 2, \n                            family = \"Hansen\"))\n\nhead(acc_Hansen)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  ac.hexagons.demand..eldercare.capacity..distmat_km..power...2..\n1                                                    1.648313e-14\n2                                                    1.096143e-16\n3                                                    3.865857e-17\n4                                                    1.482856e-17\n5                                                    1.051348e-17\n6                                                    5.076391e-18\n```\n\n\n:::\n:::\n\n\n\n### Renaming Columns and Formatting Data\n\nThe default field names are messy, so we rename the output column to `accHansen` and convert the data to a tibble format.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncolnames(acc_Hansen) <- \"accHansen\"\nacc_Hansen <- tbl_df(acc_Hansen)\n\nhead(acc_Hansen)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 6 × 1\n  accHansen\n      <dbl>\n1  1.65e-14\n2  1.10e-16\n3  3.87e-17\n4  1.48e-17\n5  1.05e-17\n6  5.08e-18\n```\n\n\n:::\n:::\n\n\n\n### Joining with Hexagons Data\n\nWe use `bind_cols()` from **dplyr** to join the accessibility data with the `hexagons` simple feature data frame. The output is saved as `hexagon_Hansen`.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhexagon_Hansen <- bind_cols(hexagons, acc_Hansen)\nclass(hexagon_Hansen)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"sf\"         \"data.frame\"\n```\n\n\n:::\n:::\n\n\n\nNote that `hexagon_Hansen` is a simple feature data frame and not a typical tibble data frame.\n\n### Visualising Hansen's Accessibility\n\n#### Extracting Map Extent\n\nFirst, we extract the extent of the `hexagons` data using `st_bbox()` from the **sf** package.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmapex <- st_bbox(hexagons)\n```\n:::\n\n\n\n#### Creating the Map\n\nWe use **tmap** to visualize accessibility to eldercare centers with Hansen's method. The map shows accessibility in Singapore with color-coded hexagons.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntmap_mode(\"plot\")\ntm_shape(hexagon_Hansen, bbox = mapex) + \n  tm_fill(col = \"accHansen\", n = 10, style = \"quantile\",\n          border.col = \"black\", border.lwd = 1) +\ntm_shape(eldercare) +\n  tm_symbols(size = 0.1) +\n  tm_layout(main.title = \"Accessibility to eldercare: Hansen method\",\n            main.title.position = \"center\", main.title.size = 2,\n            legend.outside = FALSE, legend.height = 0.45, \n            legend.width = 3.0, legend.format = list(digits = 6),\n            legend.position = c(\"right\", \"top\"), frame = TRUE) +\n  tm_compass(type=\"8star\", size = 2) +\n  tm_scale_bar(width = 0.15) +\n  tm_grid(lwd = 0.1, alpha = 0.5)\n```\n\n::: {.cell-output-display}\n![](Hands-on_Ex09a_files/figure-html/hansen_method-1.png){width=1152}\n:::\n:::\n\n\n\n### Statistical Graphic Visualization\n\nIn this section, we will compare the distribution of Hansen’s accessibility values by URA Planning Region.\n\n#### Comparing Hansen's Accessibility by Region\n\nWe first add the planning region field to `hexagon_Hansen` by spatially joining it with the `mpsz` dataset.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhexagon_Hansen <- st_join(hexagon_Hansen, mpsz, join = st_intersects)\n```\n:::\n\n\n\nThen, we use `ggplot()` to visualize the distribution of Hansen's accessibility values by URA Planning Region, using a boxplot.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(data=hexagon_Hansen, \n       aes(y = log(accHansen), x= REGION_N)) +\n  geom_boxplot() +\n  geom_point(stat=\"summary\", fun.y=\"mean\", colour =\"red\", size=2)\n```\n\n::: {.cell-output-display}\n![](Hands-on_Ex09a_files/figure-html/hexagon_hansen_boxplot-1.png){width=672}\n:::\n:::\n\n\n\n::: callout-note\n**Observations:** The Central Region shows the highest and most consistent accessibility, while the West Region exhibits the most variation and lower overall accessibility. The East Region has many outliers, indicating some areas with very low accessibility compared to the rest. The North-East and North Regions show moderate variation, with the North Region exhibiting more negative extremes than the North-East.\n:::\n\n## Modelling and Visualising Accessibility using KD2SFCA Method\n\n### Computing Accessibility\n\nWe calculate accessibility using the KD2SFCA method with the `ac()` function from **SpatialAcc**. `data.frame()` is used to save the output in a data frame called `acc_KD2SFCA`.\n\nNote that KD2SFCA is used for family argument.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nacc_KD2SFCA <- data.frame(ac(hexagons$demand, eldercare$capacity, distmat_km, d0 = 50, power = 2, family = \"KD2SFCA\"))\ncolnames(acc_KD2SFCA) <- \"accKD2SFCA\"\nacc_KD2SFCA <- tibble::as_tibble(acc_KD2SFCA)\nhexagon_KD2SFCA <- bind_cols(hexagons, acc_KD2SFCA)\n```\n:::\n\n\n\n### Visualizing KD2SFCA Accessibility\n\nWe create a map showing accessibility using the KD2SFCA method.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntmap_mode(\"plot\")\ntm_shape(hexagon_KD2SFCA, bbox = mapex) + \n  tm_fill(col = \"accKD2SFCA\", n = 10, style = \"quantile\", border.col = \"black\", border.lwd = 1) +\n  tm_shape(eldercare) + tm_symbols(size = 0.1) +\n  tm_layout(main.title = \"Accessibility to Eldercare: KD2SFCA Method\", main.title.position = \"center\", main.title.size = 2)\n```\n\n::: {.cell-output-display}\n![](Hands-on_Ex09a_files/figure-html/unnamed-chunk-17-1.png){width=1152}\n:::\n:::\n\n\n\n### Statistical Graphic Visualisation\n\nNow, we will compare the distribution of KD2CFA accessibility values by URA Planning Region.\n\nFirstly, we need to add the planning region field into *hexagon_KD2SFCA* simple feature data frame by using the code below.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhexagon_KD2SFCA <- st_join(hexagon_KD2SFCA, mpsz, \n                          join = st_intersects)\n```\n:::\n\n\n\nNext, ggplot() will be used to plot the distribution by using boxplot graphical method.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(data=hexagon_KD2SFCA, \n       aes(y = accKD2SFCA, \n           x= REGION_N)) +\n  geom_boxplot() +\n  geom_point(stat=\"summary\", \n             fun.y=\"mean\", \n             colour =\"red\", \n             size=2)\n```\n\n::: {.cell-output-display}\n![](Hands-on_Ex09a_files/figure-html/unnamed-chunk-19-1.png){width=672}\n:::\n:::\n\n\n\n::: callout-note\n**Observations:**\n\n-   The Central Region stands out with significantly higher accessibility to services compared to other regions.\n-   Most regions have lower accessibility, with minimal differences between the East, North-East, North, and West Regions.\n:::\n\n## Modelling and Visualising Accessibility using Spatial Accessibility Measure (SAM) Method\n\n### Computing Accessibility\n\nWe repeat the steps for the SAM method, using `ac()`.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nacc_SAM <- data.frame(ac(hexagons$demand, eldercare$capacity, distmat_km, d0 = 50, power = 2, family = \"SAM\"))\ncolnames(acc_SAM) <- \"accSAM\"\nacc_SAM <- tbl_df(acc_SAM)\nhexagon_SAM <- bind_cols(hexagons, acc_SAM)\n```\n:::\n\n\n\n### Visualizing SAM Accessibility\n\nWe create a map to visualize SAM accessibility.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntm_shape(hexagon_SAM, bbox = mapex) + \n  tm_fill(col = \"accSAM\", n = 10, style = \"quantile\", border.col = \"black\", border.lwd = 1) +\n  tm_shape(eldercare) + tm_symbols(size = 0.1) +\n  tm_layout(main.title = \"Accessibility to Eldercare: SAM Method\", main.title.position = \"center\", main.title.size = 2)\n```\n\n::: {.cell-output-display}\n![](Hands-on_Ex09a_files/figure-html/unnamed-chunk-21-1.png){width=1152}\n:::\n:::\n\n\n\n### Comparing SAM Accessibility by Region\n\nWe add the planning region field to `hexagon_SAM` and visualize accessibility values using boxplots.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhexagon_SAM <- st_join(hexagon_SAM, mpsz, join = st_intersects)\n\nggplot(data=hexagon_SAM, \n       aes(y = accSAM, x= REGION_N)) +\n  geom_boxplot() +\n  geom_point(stat=\"summary\", fun.y=\"mean\", colour =\"red\", size=2)\n```\n\n::: {.cell-output-display}\n![](Hands-on_Ex09a_files/figure-html/unnamed-chunk-22-1.png){width=672}\n:::\n:::\n\n\n\n::: callout-note\n**Observations:**\n\nA relatively large number of smaller outliers indicate some areas within the Central Region have much higher accessibility than most others.\n:::\n\n::: callout-note\n**Overall Observations comparing the three methods:**\n\n-   Across all three methods—Hansen, KD2SFCA, and SAM—the Central Region consistently had the highest accessibility values.\n\n-   The Hansen method revealed a broader range of accessibility across the Central Region, while KD2SFCA and SAM produced similar results with fewer outliers and a more concentrated range of values.\n:::\n",
    "supporting": [
      "Hands-on_Ex09a_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}