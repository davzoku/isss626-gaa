{
  "hash": "c625db231a631d5514a8c39159267494",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"In-Class Exercise 5\"\nsubtitle: \"In this exercise, we will perform global and local measures of spatial autocorrelation using sfdep package.\"\n# draft: true\ndate: \"Sep 23, 2024\"\ndate-modified: \"last-modified\"\nauthor: Teng Kok Wai (Walter)\nexecute:\n  echo: true # Include the source code in output\n  eval: true\n  freeze: auto\n  message: false\n  warning: false # if false, don't include warnings in the output\nformat:\n  html:\n    code-link: true\n    toc: true\nnumber-sections: true\nnumber-offset: 1\neditor: visual\n---\n\n\n\n## Exercise Reference\n\n[ISSS626 Geospatial Analytics and Applications - In-class Exercise 5: Global and Local Measures of Spatial Autocorrelation: sfdep methods](https://isss626-ay2024-25aug.netlify.app/in-class_ex/in-class_ex05/in-class_ex05-glsa#/title-slide)\n\n## Overview\n\nIn this exercise, we will use the **sfdep** package to perform global and local measures of spatial autocorrelation using Hunan's spatial data. In Hands-on Exercise 5, we learnt to perform spatial autocorrelation using **spdep** package.\n\n::: callout-note\nThe **sfdep** and **spdep** packages in R are both designed for spatial data analysis, particularly focusing on spatial autocorrelation, but they differ in their approach and compatibility with modern R data structures.\n\n-   **spdep**: This is the older and more established package for spatial dependence analysis in R. It provides functions for creating spatial weights, spatial lag models, and global and local spatial autocorrelation statistics such as Moran's I. However, **spdep** was originally built to work with the `sp` package, which uses the older `Spatial*` classes for handling spatial data.\n\n-   **sfdep**: This is a newer package designed to work seamlessly with the **sf** package, which has become the standard for handling spatial data in R using simple features. **sfdep** provides an interface for spatial dependence analysis that is compatible with **sf**'s `sf` objects (simple feature geometries) and makes extensive use of **tidyverse** conventions, such as list columns, which allow for more flexible and tidy manipulation of spatial data.\n\n### Key Differences:\n\n1.  **Data Structures**:\n\n    -   **spdep** works with `Spatial*` objects from the `sp` package.\n    -   **sfdep** works with `sf` objects from the `sf` package, which are easier to integrate with modern R workflows and the tidyverse ecosystem.\n\n2.  **Integration**:\n\n    -   **sfdep** is more compatible with modern workflows using the **tidyverse**, allowing for easier manipulation of data within data frames and list columns.\n    -   **spdep** relies on the older base R style and is less intuitive when working with modern data pipelines.\n\n3.  **Functionality**:\n\n    -   Both packages provide similar functionalities for spatial autocorrelation, such as computing Moran's I and local Moran's I.\n    -   **sfdep** introduces new functionalities that leverage list columns for easier spatial dependence operations.\n\n**sfdep can essentially be considered a wrapper around the functionality provided by spdep, designed to work with the modern sf (simple features) framework for spatial data in R.**\n:::\n\n## Learning Outcome\n\n-   Perform global Moran's I test for spatial autocorrelation.\n-   Compute and visualize local Moran's I and Gi\\* statistics for identifying clusters and outliers.\n-   Create choropleth maps to display the results of spatial autocorrelation analysis.\n\n## Import the R Packages\n\nThe following R packages will be used in this exercise:\n\n| **Package** | **Purpose** | **Use Case in Exercise** |\n|--------------|--------------------------------|--------------------------|\n| **sf** | Handles spatial data; imports, manages, and processes vector-based geospatial data. | Importing and managing geospatial data, such as Hunan's county boundary shapefile. |\n| **sfdep** | Provides functions for spatial autocorrelation, including Moran's I and local Moran's I. | Performing spatial autocorrelation analysis with global and local measures. |\n| **tidyverse** | A collection of R packages for data science tasks like data manipulation, visualization, and modeling. | Wrangling aspatial data and joining with spatial datasets. |\n| **tmap** | Creates static and interactive thematic maps using cartographic quality elements. | Visualizing spatial analysis results and creating thematic maps. |\n\nTo install and load these packages, use the following code:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\npacman::p_load(sf, sfdep, tmap, tidyverse)\n```\n:::\n\n\n\n## The Data\n\nThe following datasets will be used in this exercise:\n\n| **Data Set** | **Description** | **Format** |\n|---------------|------------------------------------------|---------------|\n| **Hunan County Boundary Layer** | A geospatial dataset containing Hunan's county boundaries. | ESRI Shapefile |\n| **Hunan_2012.csv** | A CSV file containing selected local development indicators for Hunan in 2012. | CSV |\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhunan <- st_read(dsn = \"data/geospatial\",\n                 layer = \"Hunan\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nReading layer `Hunan' from data source \n  `/Users/walter/code/isss626/isss626-gaa/In-class_Ex/In-class_Ex05/data/geospatial' \n  using driver `ESRI Shapefile'\nSimple feature collection with 88 features and 7 fields\nGeometry type: POLYGON\nDimension:     XY\nBounding box:  xmin: 108.7831 ymin: 24.6342 xmax: 114.2544 ymax: 30.12812\nGeodetic CRS:  WGS 84\n```\n\n\n:::\n\n```{.r .cell-code}\nglimpse(hunan)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nRows: 88\nColumns: 8\n$ NAME_2     <chr> \"Changde\", \"Changde\", \"Changde\", \"Changde\", \"Changde\", \"Cha…\n$ ID_3       <int> 21098, 21100, 21101, 21102, 21103, 21104, 21109, 21110, 211…\n$ NAME_3     <chr> \"Anxiang\", \"Hanshou\", \"Jinshi\", \"Li\", \"Linli\", \"Shimen\", \"L…\n$ ENGTYPE_3  <chr> \"County\", \"County\", \"County City\", \"County\", \"County\", \"Cou…\n$ Shape_Leng <dbl> 1.869074, 2.360691, 1.425620, 3.474325, 2.289506, 4.171918,…\n$ Shape_Area <dbl> 0.10056190, 0.19978745, 0.05302413, 0.18908121, 0.11450357,…\n$ County     <chr> \"Anxiang\", \"Hanshou\", \"Jinshi\", \"Li\", \"Linli\", \"Shimen\", \"L…\n$ geometry   <POLYGON [°]> POLYGON ((112.0625 29.75523..., POLYGON ((112.2288 …\n```\n\n\n:::\n:::\n\n\n\n::: callout-tip\nFor admin boundaries, we will typically encounter **polygon or multipolygon** data objects.\n\nA polygon represents a single contiguous area, while a multipolygon consists of multiple disjoint areas grouped together (e.g., islands that belong to the same admin region).\n:::\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhunan2012 <- read_csv(\"data/aspatial/Hunan_2012.csv\")\nglimpse(hunan2012)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nRows: 88\nColumns: 29\n$ County      <chr> \"Anhua\", \"Anren\", \"Anxiang\", \"Baojing\", \"Chaling\", \"Changn…\n$ City        <chr> \"Yiyang\", \"Chenzhou\", \"Changde\", \"Hunan West\", \"Zhuzhou\", …\n$ avg_wage    <dbl> 30544, 28058, 31935, 30843, 31251, 28518, 54540, 28597, 33…\n$ deposite    <dbl> 10967.0, 4598.9, 5517.2, 2250.0, 8241.4, 10860.0, 24332.0,…\n$ FAI         <dbl> 6831.7, 6386.1, 3541.0, 1005.4, 6508.4, 7920.0, 33624.0, 1…\n$ Gov_Rev     <dbl> 456.72, 220.57, 243.64, 192.59, 620.19, 769.86, 5350.00, 1…\n$ Gov_Exp     <dbl> 2703.0, 1454.7, 1779.5, 1379.1, 1947.0, 2631.6, 7885.5, 11…\n$ GDP         <dbl> 13225.0, 4941.2, 12482.0, 4087.9, 11585.0, 19886.0, 88009.…\n$ GDPPC       <dbl> 14567, 12761, 23667, 14563, 20078, 24418, 88656, 10132, 17…\n$ GIO         <dbl> 9276.90, 4189.20, 5108.90, 3623.50, 9157.70, 37392.00, 513…\n$ Loan        <dbl> 3954.90, 2555.30, 2806.90, 1253.70, 4287.40, 4242.80, 4053…\n$ NIPCR       <dbl> 3528.3, 3271.8, 7693.7, 4191.3, 3887.7, 9528.0, 17070.0, 3…\n$ Bed         <dbl> 2718, 970, 1931, 927, 1449, 3605, 3310, 582, 2170, 2179, 1…\n$ Emp         <dbl> 494.310, 290.820, 336.390, 195.170, 330.290, 548.610, 670.…\n$ EmpR        <dbl> 441.4, 255.4, 270.5, 145.6, 299.0, 415.1, 452.0, 127.6, 21…\n$ EmpRT       <dbl> 338.0, 99.4, 205.9, 116.4, 154.0, 273.7, 219.4, 94.4, 174.…\n$ Pri_Stu     <dbl> 54.175, 33.171, 19.584, 19.249, 33.906, 81.831, 59.151, 18…\n$ Sec_Stu     <dbl> 32.830, 17.505, 17.819, 11.831, 20.548, 44.485, 39.685, 7.…\n$ Household   <dbl> 290.4, 104.6, 148.1, 73.2, 148.7, 211.2, 300.3, 76.1, 139.…\n$ Household_R <dbl> 234.5, 121.9, 135.4, 69.9, 139.4, 211.7, 248.4, 59.6, 110.…\n$ NOIP        <dbl> 101, 34, 53, 18, 106, 115, 214, 17, 55, 70, 44, 84, 74, 17…\n$ Pop_R       <dbl> 670.3, 243.2, 346.0, 184.1, 301.6, 448.2, 475.1, 189.6, 31…\n$ RSCG        <dbl> 5760.60, 2386.40, 3957.90, 768.04, 4009.50, 5220.40, 22604…\n$ Pop_T       <dbl> 910.8, 388.7, 528.3, 281.3, 578.4, 816.3, 998.6, 256.7, 45…\n$ Agri        <dbl> 4942.253, 2357.764, 4524.410, 1118.561, 3793.550, 6430.782…\n$ Service     <dbl> 5414.5, 3814.1, 14100.0, 541.8, 5444.0, 13074.6, 17726.6, …\n$ Disp_Inc    <dbl> 12373, 16072, 16610, 13455, 20461, 20868, 183252, 12379, 1…\n$ RORP        <dbl> 0.7359464, 0.6256753, 0.6549309, 0.6544614, 0.5214385, 0.5…\n$ ROREmp      <dbl> 0.8929619, 0.8782065, 0.8041262, 0.7460163, 0.9052651, 0.7…\n```\n\n\n:::\n:::\n\n\n\n::: callout-note\nRecall that to do left join, we need a common identifier between the 2 data objects. The content must be the same eg. same format and same case. In Hands-on Exercise 1B, we need to (PA, SZ) in the dataset to uppercase before we can join the data.\n:::\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhunan <- left_join(hunan,hunan2012) %>%\n  select(1:4, 7, 15)\nglimpse(hunan)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nRows: 88\nColumns: 7\n$ NAME_2    <chr> \"Changde\", \"Changde\", \"Changde\", \"Changde\", \"Changde\", \"Chan…\n$ ID_3      <int> 21098, 21100, 21101, 21102, 21103, 21104, 21109, 21110, 2111…\n$ NAME_3    <chr> \"Anxiang\", \"Hanshou\", \"Jinshi\", \"Li\", \"Linli\", \"Shimen\", \"Li…\n$ ENGTYPE_3 <chr> \"County\", \"County\", \"County City\", \"County\", \"County\", \"Coun…\n$ County    <chr> \"Anxiang\", \"Hanshou\", \"Jinshi\", \"Li\", \"Linli\", \"Shimen\", \"Li…\n$ GDPPC     <dbl> 23667, 20981, 34592, 24473, 25554, 27137, 63118, 62202, 7066…\n$ geometry  <POLYGON [°]> POLYGON ((112.0625 29.75523..., POLYGON ((112.2288 2…\n```\n\n\n:::\n:::\n\n\n\n## Visualising Choropleth Map of GDPPC of Hunan\n\nTo plot a choropleth map showing the distribution of GDPPC of Hunan province:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntmap_mode(\"plot\")\ntm_shape(hunan) +\n  tm_fill(\"GDPPC\",\n          style = \"quantile\",\n          palette = \"Blues\",\n          title = \"GDPPC\") +\n  tm_layout(main.title = \"Distribution of GDP per capita by county, Hunan Province\",\n            main.title.position = \"center\",\n            main.title.size = 1.2,\n            legend.height = 0.45,\n            legend.width = 0.35,\n            frame = TRUE) +\n  tm_borders(alpha = 0.5) +\n  tm_compass(type=\"8star\", size = 2) +\n  tm_scale_bar() +\n  tm_grid(alpha =0.2)\n```\n\n::: {.cell-output-display}\n![](In-class_Ex05_files/figure-html/hunan_choropleth-1.png){width=864}\n:::\n:::\n\n\n\n## Global Measures of Spatial Association\n\n### Deriving Queen's contiguity weights: sfdep methods\n\nTo derive the Queen's contiguity weights:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nwm_q <- hunan %>%\n  mutate(nb = st_contiguity(geometry),\n         wt = st_weights(nb,\n                         style = \"W\"),\n         .before = 1)\n```\n:::\n\n\n\n::: callout-tip\nNotice that `st_weights()` provides tree arguments, they are:\n\n-   *nb*: A neighbor list object as created by st_neighbors().\n-   *style*: Default \"W\" for row standardized weights. This value can also be \"B\", \"C\", \"U\", \"minmax\", and \"S\". B is the basic binary coding, W is row standardised (sums over all links to n), C is globally standardised (sums over all links to n), U is equal to C divided by the number of neighbours (sums over all links to unity), while S is the variance-stabilizing coding scheme proposed by Tiefelsdorf et al. 1999, p. 167-168 (sums over all links to n).\n-   *allow_zero*: If TRUE, assigns zero as lagged value to zone without neighbors.\n:::\n\n### Computing Global Moran' I\n\nWe will use [`global_moran()`](https://sfdep.josiahparry.com/reference/global_moran) function to compute the Moran’s I value.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmoranI <- global_moran(\n  wm_q$GDPPC, # Target variable: GDP per capita\n  wm_q$nb, # Neighborhood structure\n  wm_q$wt # Spatial weights\n)\n\nglimpse(moranI)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nList of 2\n $ I: num 0.301\n $ K: num 7.64\n```\n\n\n:::\n:::\n\n\n\n::: callout-tip\nUnlike the `spdep` package, the output of the `global_moran()` function is a tibble data frame, making it easier to work with in the tidyverse environment.\n:::\n\n## Performing Global Moran's I Test\n\n::: callout-tip\nPreviously, we calculated the Moran's I statistic using the `global_moran()` function. However, this approach does not allow for formal hypothesis testing, as it only returns the Moran's I value, not the associated p-value or significance level. Therefore, we cannot determine whether spatial autocorrelation is statistically significant with this method.\n:::\n\nTo conduct a proper hypothesis test, we need to use the `global_moran_test()` function from the `sfdep` package, which computes the Moran's I statistic and also performs a permutation-based significance test. This allows us to assess whether the observed spatial autocorrelation is significantly different from what would be expected under spatial randomness.\n\nThe following code demonstrates how to perform the Moran's I test:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nglobal_moran_test(\n  wm_q$GDPPC, # Target variable: GDP per capita\n  wm_q$nb, # Neighborhood structure\n  wm_q$wt # Spatial weights\n)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\n\tMoran I test under randomisation\n\ndata:  x  \nweights: listw    \n\nMoran I statistic standard deviate = 4.7351, p-value = 1.095e-06\nalternative hypothesis: greater\nsample estimates:\nMoran I statistic       Expectation          Variance \n      0.300749970      -0.011494253       0.004348351 \n```\n\n\n:::\n:::\n\n\n\n::: callout-tip\n-   The default for `alternative` argument is \"two.sided\". Other supported arguments are \"greater\" or \"less\". randomization, and\n-   By default the `randomization` argument is **TRUE**. If FALSE, under the assumption of normality.\n:::\n\nThis method not only calculates the Moran's I statistic but also provides a p-value for assessing the significance of the spatial autocorrelation.\n\n::: callout-note\n**Observations:**\n\n-   **Moran's I statistic:** 0.301, indicating moderate positive spatial autocorrelation.\n-   **P-value:** 1.095e-06, highly significant, confirming strong evidence of positive spatial autocorrelation.\n:::\n\n## Perfoming Global Moran's I Permutation Test\n\nIn practice, a Monte Carlo simulation should be used to perform the statistical test. In the `sfdep` package, this is supported by the `global_moran_perm()` function.\n\nTo ensure that the computation is reproducible, we will use `set.seed()` before performing simulation.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nset.seed(1234)\n```\n:::\n\n\n\nNow we will perform Monte Carlo simulation using `global_moran_perm()`.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nglobal_moran_perm(wm_q$GDPPC,\n                  wm_q$nb,\n                  wm_q$wt,\n                  nsim = 99)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\n\tMonte-Carlo simulation of Moran I\n\ndata:  x \nweights: listw  \nnumber of simulations + 1: 100 \n\nstatistic = 0.30075, observed rank = 100, p-value < 2.2e-16\nalternative hypothesis: two.sided\n```\n\n\n:::\n:::\n\n\n\n::: callout-note\n**Observations:**\n\nThe statistical report on previous tab shows that the p-value is smaller than alpha value of 0.05. Hence, we have enough statistical evidence to reject the null hypothesis that the spatial distribution of GPD per capita are resemble random distribution (i.e. independent from spatial). Because the Moran's I statistics is greater than 0. We can infer that the spatial distribution shows sign of clustering.\n:::\n\n## Local Measures of Spatial Association\n\n## LISA Map\n\nLISA map is a categorical map showing **outliers** and **clusters**. There are two types of outliers namely: High-Low and Low-High outliers. Likewise, there are two type of clusters namely: High-High and Low-Low cluaters. In fact, LISA map is an interpreted map by combining local Moran's I of geographical areas and their respective p-values.\n\n## Computing Local Moran's I\n\nIn this section, we will compute Local Moran's I of GDPPC at county level by using [`local_moran()`](https://sfdep.josiahparry.com/reference/local_moran.html) of sfdep package.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlisa <- wm_q %>%\n  mutate(local_moran = local_moran(\n    GDPPC, nb, wt, nsim = 99),\n         .before = 1) %>%\n  unnest(local_moran)\n```\n:::\n\n\n\n::: callout-tip\n-   We use `unnest()` in this context to convert the nested list column created by `local_moran()` into multiple rows, one for each simulation result per observation.\n-   The `local_moran()` function from the `sfdep` package returns a nested list, with each element containing the results of local Moran’s I statistic for each spatial unit.\n-   Unnesting helps in expanding this list into individual rows, making each result (e.g., local Moran’s I values, p-values) accessible in a tidy, flat data frame format.\n-   This step is crucial for easier manipulation, filtering, and visualization of the spatial autocorrelation results, allowing us to work with the data in a more intuitive and flexible way.\n\nThus, `unnest()` is applied to handle and process the simulation results efficiently.\n\n------------------------------------------------------------------------\n\nThe output of `local_moran()` is a sf data.frame containing the columns ii, eii, var_ii, z_ii, p_ii, p_ii_sim, and p_folded_sim.\n\n-   ii: local moran statistic\n-   eii: expectation of local moran statistic; for localmoran_permthe permutation sample means\n-   var_ii: variance of local moran statistic; for localmoran_permthe permutation sample standard deviations\n-   z_ii: standard deviate of local moran statistic; for localmoran_perm based on permutation sample means and standard deviations p_ii: p-value of local moran statistic using pnorm(); for localmoran_perm using standard deviatse based on permutation sample means and standard deviations p_ii_sim: For `localmoran_perm()`, `rank()` and `punif()` of observed statistic rank for \\[0, 1\\] p-values using `alternative=` -p_folded_sim: the simulation folded \\[0, 0.5\\] range ranked p-value (based on https://github.com/pysal/esda/blob/4a63e0b5df1e754b17b5f1205b cadcbecc5e061/esda/crand.py#L211-L213)\n-   skewness: For `localmoran_perm`, the output of e1071::skewness() for the permutation samples underlying the standard deviates\n-   kurtosis: For `localmoran_perm`, the output of e1071::kurtosis() for the permutation samples underlying the standard deviates.\n:::\n\n## Visualising Local Moran's I and p-value\n\nWhen interpreting / visualizing local Moran's I, we should plot the Moran's I and p-value side by side.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntmap_mode(\"plot\")\nmap1 <- tm_shape(lisa) +\n  tm_fill(\"ii\") +\n  tm_borders(alpha = 0.5) +\n  tm_view(set.zoom.limits = c(6,8)) +\n  tm_layout(\n    main.title = \"Local Moran's I of GDPPC\",\n    main.title.size = 0.8\n  )\n\nmap2 <- tm_shape(lisa) +\n  tm_fill(\"p_ii\") +\n  tm_borders(alpha = 0.5) +\n  tm_view(set.zoom.limits = c(6,8)) +\n  tm_layout(\n    main.title = \"p-value of Local Moran's I\",\n    main.title.size = 0.8\n  )\n\ntmap_arrange(map1, map2, ncol = 2)\n```\n\n::: {.cell-output-display}\n![](In-class_Ex05_files/figure-html/local_moran_i_p_value-1.png){width=1152}\n:::\n:::\n\n\n\n### Plotting LISA Map\n\nIn lisa sf data.frame, we can find three fields contain the LISA categories. They are *mean*, *median* and *pysal*. In general, classification in *mean* will be used as shown in the code below.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlisa_sig <- lisa  %>%\n  filter(p_ii_sim < 0.05)\ntmap_mode(\"plot\")\ntm_shape(lisa) +\n  tm_polygons() +\n  tm_borders(alpha = 0.5) +\ntm_shape(lisa_sig) +\n  tm_fill(\"mean\") +\n  tm_borders(alpha = 0.4)\n```\n\n::: {.cell-output-display}\n![](In-class_Ex05_files/figure-html/lisa_map-1.png){width=672}\n:::\n:::\n\n\n\n## Hot Spot and Cold Spot Area Analysis\n\nHot Spot and Cold Spot Analysis (HCSA) uses spatial weights to identify locations of statistically significant hot spots and cold spots within a spatially weighted attribute. These spots are identified based on a calculated distance that groups features when similar high (hot) or low (cold) values are found in proximity to one another. The polygon features typically represent administrative boundaries or a custom grid structure.\n\n### Computing local Gi\\* statistics\n\nAs usual, we will need to derive a spatial weight matrix before we can compute local Gi\\* statistics. Code chunk below will be used to derive a spatial weight matrix by using sfdep functions and tidyverse approach.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nwm_idw <- hunan %>%\n  mutate(nb = include_self(\n    st_contiguity(geometry)),\n    wts = st_inverse_distance(nb,\n                              geometry,\n                              scale = 1,\n                              alpha = 1),\n         .before = 1)\n```\n:::\n\n\n\n::: callout-tip\n-   Gi\\* and local Gi\\* are **distance-based spatial statistics**. Hence, distance methods instead of contiguity methods should be used to derive the spatial weight matrix.\n-   Since we are going to compute Gi\\* statistics, `include_self()`is used.\n:::\n\n### Computing Local Gi\\* statistics\n\nNow, we will compute the local Gi\\* by using the code below.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nHCSA <- wm_idw %>%\n  mutate(local_Gi = local_gstar_perm(\n    GDPPC, nb, wts, nsim = 99),\n         .before = 1) %>%\n  unnest(local_Gi)\nHCSA\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nSimple feature collection with 88 features and 18 fields\nGeometry type: POLYGON\nDimension:     XY\nBounding box:  xmin: 108.7831 ymin: 24.6342 xmax: 114.2544 ymax: 30.12812\nGeodetic CRS:  WGS 84\n# A tibble: 88 × 19\n    gi_star cluster     e_gi  var_gi std_dev p_value p_sim p_folded_sim skewness\n      <dbl> <fct>      <dbl>   <dbl>   <dbl>   <dbl> <dbl>        <dbl>    <dbl>\n 1  0.261   Low     0.00126  1.07e-7  0.283  7.78e-1  0.66         0.33    0.783\n 2 -0.276   Low     0.000969 4.76e-8 -0.123  9.02e-1  0.98         0.49    0.713\n 3  0.00573 High    0.00156  2.53e-7 -0.0571 9.54e-1  0.78         0.39    0.972\n 4  0.528   High    0.00155  2.97e-7  0.321  7.48e-1  0.56         0.28    0.942\n 5  0.466   High    0.00137  2.76e-7  0.386  7.00e-1  0.52         0.26    1.32 \n 6 -0.445   High    0.000992 7.08e-8 -0.588  5.57e-1  0.68         0.34    0.692\n 7  2.99    High    0.000700 4.05e-8  3.13   1.74e-3  0.04         0.02    0.975\n 8  2.04    High    0.00152  1.58e-7  1.77   7.59e-2  0.16         0.08    1.26 \n 9  4.42    High    0.00130  1.18e-7  4.22   2.39e-5  0.02         0.01    1.20 \n10  1.21    Low     0.00175  1.25e-7  1.49   1.36e-1  0.18         0.09    0.408\n# ℹ 78 more rows\n# ℹ 10 more variables: kurtosis <dbl>, nb <nb>, wts <list>, NAME_2 <chr>,\n#   ID_3 <int>, NAME_3 <chr>, ENGTYPE_3 <chr>, County <chr>, GDPPC <dbl>,\n#   geometry <POLYGON [°]>\n```\n\n\n:::\n:::\n\n\n\n### Visualising Local Hot Spot and Cold Spot Areas (HCSA)\n\nSimilarly, for effective comparison, we should plot the local Gi\\* values with its p-value.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntmap_mode(\"plot\")\nmap1 <- tm_shape(HCSA) +\n  tm_fill(\"gi_star\") +\n  tm_borders(alpha = 0.5) +\n  tm_view(set.zoom.limits = c(6,8)) +\n  tm_layout(main.title = \"Gi* of GDPPC\",\n            main.title.size = 0.8)\n\nmap2 <- tm_shape(HCSA) +\n  tm_fill(\"p_value\",\n          breaks = c(0, 0.001, 0.01, 0.05, 1),\n              labels = c(\"0.001\", \"0.01\", \"0.05\", \"Not sig\")) +\n  tm_borders(alpha = 0.5) +\n  tm_layout(main.title = \"p-value of Gi*\",\n            main.title.size = 0.8)\n\ntmap_arrange(map1, map2, ncol = 2)\n```\n\n::: {.cell-output-display}\n![](In-class_Ex05_files/figure-html/local_hcsa-1.png){width=1152}\n:::\n:::\n\n\n\nTo visualize HCSA, we will plot the significant (i.e. p-values less than 0.05) hot spot and cold spot areas by using appropriate tmap functions as shown below.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nHCSA_sig <- HCSA  %>%\n  filter(p_sim < 0.05)\ntmap_mode(\"plot\")\ntm_shape(HCSA) +\n  tm_polygons() +\n  tm_borders(alpha = 0.5) +\ntm_shape(HCSA_sig) +\n  tm_fill(\"cluster\") +\n  tm_borders(alpha = 0.4)\n```\n\n::: {.cell-output-display}\n![](In-class_Ex05_files/figure-html/hcsa-1.png){width=672}\n:::\n:::\n\n\n\n::: callout-note\n**Observations:** The plot reveals that there is one hot spot area and two cold spot areas. Interestingly, the hot spot areas coincide with the High-high cluster identifies by using local Moran's I method in the earlier sub-section.\n:::\n",
    "supporting": [
      "In-class_Ex05_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}